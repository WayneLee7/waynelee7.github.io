<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WayneLee</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-10T19:04:18.982Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WayneLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue面试题整理</title>
    <link href="http://yoursite.com/2021/06/20/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/06/20/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2021-06-20T05:52:42.000Z</published>
    <updated>2021-07-10T19:04:18.982Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是-MVVM？"><a href="#什么是-MVVM？" class="headerlink" title="什么是 MVVM？"></a>什么是 MVVM？</h4><p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p><a id="more"></a><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><h4 id="vue的优点是什么？"><a href="#vue的优点是什么？" class="headerlink" title="vue的优点是什么？"></a>vue的优点是什么？</h4><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p><p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p><p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p><h4 id="组件之间的传值？"><a href="#组件之间的传值？" class="headerlink" title="组件之间的传值？"></a>组件之间的传值？</h4><ul><li><p>父组件通过标签上<code>:data=data</code>方式定义传值</p></li><li><p>子组件通过<code>props</code>方法接受数据</p></li><li><p>子组件通过<code>$emit</code>方法传递参数</p></li></ul><h4 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h4><p>vue框架中状态管理。在main.js引入store注入。新建一个目录store 。场景有：单页应用中，组件之间的状态，音乐播放、登录状态、加入购物车等。</p><h4 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h4><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module。</p><h4 id="vuex的State特性"><a href="#vuex的State特性" class="headerlink" title="vuex的State特性"></a>vuex的State特性</h4><p>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。</p><p>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。</p><p>通过mapState把全局 state 和 getters 映射到当前组件的 computed 计算属性中。</p><h4 id="vuex的Getter特性"><a href="#vuex的Getter特性" class="headerlink" title="vuex的Getter特性"></a>vuex的Getter特性</h4><p>getters 可以对State进行计算操作，它就是Store的计算属性。</p><p>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。</p><p>如果一个状态只在一个组件内使用，可以不用getters。</p><h4 id="vuex的Mutation特性"><a href="#vuex的Mutation特性" class="headerlink" title="vuex的Mutation特性"></a>vuex的Mutation特性</h4><p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p><h4 id="不用Vuex会带来什么问题？"><a href="#不用Vuex会带来什么问题？" class="headerlink" title="不用Vuex会带来什么问题？"></a>不用Vuex会带来什么问题？</h4><p>可维护性会下降，想修改数据要维护三个地方；</p><p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p><p>增加耦合，大量的上传派发，会让耦合性大大增加，Vue用Component本意就是为了减少耦合，现在这么用，和组件化的初衷相背。</p><h4 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="headerlink" title="v-show和v-if指令的共同点和不同点"></a>v-show和v-if指令的共同点和不同点</h4><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏；</p><p>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果；</p><p>使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是-MVVM？&quot;&gt;&lt;a href=&quot;#什么是-MVVM？&quot; class=&quot;headerlink&quot; title=&quot;什么是 MVVM？&quot;&gt;&lt;/a&gt;什么是 MVVM？&lt;/h4&gt;&lt;p&gt;MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试题整理（js篇）</title>
    <link href="http://yoursite.com/2021/06/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88js%E7%AF%87%EF%BC%89/"/>
    <id>http://yoursite.com/2021/06/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88js%E7%AF%87%EF%BC%89/</id>
    <published>2021-06-20T05:51:59.000Z</published>
    <updated>2021-07-10T17:06:14.300Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JavaScript-中有几种数据类型"><a href="#JavaScript-中有几种数据类型" class="headerlink" title="JavaScript 中有几种数据类型"></a>JavaScript 中有几种数据类型</h4><p><strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><p> 基本数据类型 ：<code>String</code>、<code>Number</code>、<code>Boolean</code> 、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code>、<code>BigInt</code> ; </p><p> 引用数据类型：<code>Object</code>; </p><p><strong>不同类型的数据储存原理</strong></p><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</p><a id="more"></a><p>堆：引用数据类型（对象、数组和函数）</p><p><strong>两种类型的区别是：存储位置不同</strong></p><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</p><p>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p><h4 id="JavaScript-什么叫全局变量-什么叫局部变量了-是如何定义出来的"><a href="#JavaScript-什么叫全局变量-什么叫局部变量了-是如何定义出来的" class="headerlink" title="JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?"></a>JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?</h4><p>全局变量是在函数外部定义的变量,在JS中全局变量属于window对象</p><p>局部变量是相对与全局变量而言的,在特定过程或函数中可以访问的变量,作用域较小,当函数运行结束释放局部变量</p><h4 id="var-和-let-const-的区别"><a href="#var-和-let-const-的区别" class="headerlink" title="var 和 let const 的区别"></a>var 和 let const 的区别</h4><ul><li>var 是 ES5 语法， let const 是 ES6 语法； var 有变量提升  ; let 、const存在一个暂时性死区（暂时性死区：创建了变量但是没有初始化，没法使用变量，“Cannot access ‘value’ before initialization”），  let在变量声明之前就访问变量的话，会直接提示 ReferenceError，而不像 var 那样使用默认值 undefined: </li><li>var 和 let 是变量，可修改；const 是常量，不可修改</li><li>let const 有块级作用域（ES6），var 没有</li><li>var 可以重复声明同一个变量，let、const不能</li><li>var声明的变量会挂载在window上，而let和const声明的变量不会  </li></ul><h4 id="typeof-返回哪些类型"><a href="#typeof-返回哪些类型" class="headerlink" title="typeof 返回哪些类型"></a>typeof 返回哪些类型</h4><ul><li>值类型：<code>undefined</code> <code>string</code> <code>number</code> <code>boolean</code> <code>symbol</code></li><li>引用类型：<code>object</code> (注意： typeof null === ‘object’)</li><li>函数类型：<code>function</code></li></ul><h4 id="列举强制类型转换和隐式类型转换"><a href="#列举强制类型转换和隐式类型转换" class="headerlink" title="列举强制类型转换和隐式类型转换"></a>列举强制类型转换和隐式类型转换</h4><ul><li>强制：<code>parseInt</code> <code>parseFloat</code> <code>toString</code> 等</li><li>隐式：<code>if</code> <code>逻辑运算</code> <code>==</code> <code>+拼接字符串</code></li></ul><h4 id="split-和-join-的区别？"><a href="#split-和-join-的区别？" class="headerlink" title="split() 和 join() 的区别？"></a>split() 和 join() 的区别？</h4><p>split()方法用于把一个字符串分割成字符串数组</p><p>join() 方法用于把数组中的所有元素放入一个字符串</p><p><strong>String.split() 执行的操作与 Array.join() 执行的操作是相反的</strong></p><h4 id="数组的-pop-push-unshift-shift-分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？"><a href="#数组的-pop-push-unshift-shift-分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？" class="headerlink" title="数组的 pop push unshift shift 分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？"></a>数组的 pop push unshift shift 分别做什么功能是什么？返回值是什么？是否会对原数组造成影响？</h4><p><strong>pop</strong></p><ul><li>删除数组末尾元素</li><li>返回删除元素</li><li>改变原数组</li></ul><p><strong>push</strong></p><ul><li>向数组末尾添加元素</li><li>返回数组长度</li><li>改变原数组</li></ul><p><strong>shift</strong></p><ul><li>删除数组首个元素</li><li>返回被删除元素</li><li>改变原数组</li></ul><p><strong>unshift</strong></p><ul><li>向数组首位添加元素</li><li>返回数组长度</li><li>改变原数组</li></ul><h4 id="数组的API-有哪些是纯函数？-（不对外界产生副作用的函数就叫纯函数）"><a href="#数组的API-有哪些是纯函数？-（不对外界产生副作用的函数就叫纯函数）" class="headerlink" title="数组的API,有哪些是纯函数？  （不对外界产生副作用的函数就叫纯函数）"></a><strong>数组的API,有哪些是纯函数？</strong>  （不对外界产生副作用的函数就叫纯函数）</h4><p><code>concat</code> <code>map</code> <code>filter</code> <code>slice</code> 就是纯函数，它们具有以下特点：</p><p>不改变源数组（没有副作用）；返回一个数组</p><p>concat()把当前的数组和另一个数组合并为一个新的数组 </p><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 </p><p>filter()  过滤数组，返回符合条件的值 </p><p>slice() 拷贝数组从start到end(不包括end)的值，返回一个新数组，不会对源数组进行改变 </p><h4 id="数组-slice-和-splice-区别"><a href="#数组-slice-和-splice-区别" class="headerlink" title="数组 slice 和 splice 区别"></a>数组 slice 和 splice 区别</h4><p>slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素。 （该方法不会改变原数组） </p><p>splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。（该方法会改变原数组） </p><p>splice（index,howmany,item1,…itemX）</p><ul><li>index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。</li><li>howmany参数：必须，要删除的数量，如果为0，则不删除项目。</li><li>tem1,…itemX参数：可选，向数组添加的新项目。</li></ul><h4 id="call-apply-bind-作用和区别"><a href="#call-apply-bind-作用和区别" class="headerlink" title="call() apply() bind() 作用和区别"></a>call() apply() bind() 作用和区别</h4><p><strong>相同点</strong></p><ul><li>改变对象的执行上下文(总的来说，就是改变this的指向)。<br>this关键字，就是所谓的执行上下文。this关键字在函数中，表示的是一个指向，this的指向永远是一个对象。</li><li>都可以指定调用实参。</li></ul><p><strong>不同点</strong></p><ul><li>call()和bind()的参数是直接连续传递，而apply传递参数是以一个数组传递。</li><li>bind()会返回一个方法。</li></ul><h4 id="事件代理（委托）是什么？"><a href="#事件代理（委托）是什么？" class="headerlink" title="事件代理（委托）是什么？"></a>事件代理（委托）是什么？</h4><p>事件代理就是，本来加在子元素身上的事件，加在了其父级身上 </p><p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素 </p><p>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p><ul><li>减少整个页面所需的内存，提升整体性能</li><li>动态绑定，减少重复工作</li></ul><p>效率高，比如，不用for循环为子元素添加事件了     </p><p>js新生成的子元素也不用新为其添加事件了，程序逻辑上比较方便</p><p><strong>使用事件委托注意事项</strong></p><p>使用“事件委托”时，并不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。</p><h4 id="闭包是什么？有什么特性？有什么负面影响？"><a href="#闭包是什么？有什么特性？有什么负面影响？" class="headerlink" title="闭包是什么？有什么特性？有什么负面影响？"></a>闭包是什么？有什么特性？有什么负面影响？</h4><p> 闭包就是能够读取其他函数内部变量的函数。 </p><p> 所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁 </p><p>子函数可以一层一层读取到父元素的变量，反之不行。但假如我们需要得到函数内的局部变量，正常操作是：在函数的内部再定义一个函数，该函数称之为闭包,通过闭包，向上去读取父函数的局部变量。闭包的作用：读取局部变量；让局部变量的值始终保存在内存中。 </p><p><strong>由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</strong></p><p>原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 </p><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 </p><h4 id="如何阻止事件冒泡和默认事件？"><a href="#如何阻止事件冒泡和默认事件？" class="headerlink" title="如何阻止事件冒泡和默认事件？"></a>如何阻止事件冒泡和默认事件？</h4><p>阻止事件冒泡</p><p>e. stopPropagation()   <strong>事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转</strong></p><p>阻止默认事件</p><p>return false      <strong>事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转） </strong></p><p>e.preventDefault()    <strong>事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） </strong></p><h4 id="查找，添加，删除，移动DOM节点的方法"><a href="#查找，添加，删除，移动DOM节点的方法" class="headerlink" title="查找，添加，删除，移动DOM节点的方法"></a>查找，添加，删除，移动DOM节点的方法</h4><p><strong>在HTML当中，一切都是节点</strong>：（非常重要）</p><ul><li><strong>元素节点</strong>：HMTL标签。</li><li><strong>文本节点</strong>：标签中的文字（比如标签之间的空格、换行）</li><li><strong>属性节点</strong>：：标签的属性。</li></ul><p>整个html文档就是一个文档节点。所有的节点都是Object。</p><p><strong>访问/获取节点</strong></p><p>document.getElementById(id);　　　　　　　　 　　//返回对拥有指定id的第一个对象进行访问</p><p>document.getElementsByName(name);　　　　　　//返回带有指定名称的节点集合　　 注意拼写:Elements</p><p>document.getElementsByTagName(tagname); 　　//返回带有指定标签名的对象集合　 注意拼写：Elements</p><p>document.getElementsByClassName(classname); //返回带有指定class名称的对象集合 注意拼写：Elements</p><p><strong>创建节点/属性</strong></p><p>document.createElement(eName);　　//创建一个节点</p><p>document.createAttribute(attrName); //对某个节点创建属性</p><p>document.createTextNode(text);　　　//创建文本节点</p><p><strong>添加节点</strong></p><p> document .insertBefore(新的子节点,参考节点);</p><p>解释：</p><ul><li><p>在参考节点前插入一个新的节点。</p></li><li><p>如果参考节点为null，那么他将在父节点最后插入一个子节点。</p></li></ul><p>父节点.appendChild(新的子节点);　　　　　// 解释：父节点的最后插入一个新的子节点。 </p><p><strong>复制节点</strong></p><p>cloneNode(true | false);　　//复制某个节点  参数：是否复制原节点的所有属性</p><p><strong>删除节点</strong></p><p>父节点.removeChild(node);　　//删除某个节点的子节点 node是要删除的节点</p><p>注意：为了保证兼容性，要判断元素节点的节点类型(nodeType)，若nodeType==1，再执行删除操作。通过这个方法，就可以在 IE和 Mozilla 完成正确的操作。</p><p>nodeType 属性可返回节点的类型.最重要的节点类型是：</p><table><thead><tr><th>元素类型</th><th>节点类型</th></tr></thead><tbody><tr><td>元素element</td><td>1</td></tr><tr><td>属性attr</td><td>2</td></tr><tr><td>文本text</td><td>3</td></tr><tr><td>注释comments</td><td>8</td></tr><tr><td>文档document</td><td>9</td></tr></tbody></table><p><strong>属性操作</strong></p><p>getAttribute(name)　　　　//通过属性名称获取某个节点属性的值</p><p>setAttribute(name,value); //修改某个节点属性的值</p><p>removeAttribute(name);　 //删除某个属性</p><p><strong>查找节点</strong></p><p>parentObj.firstChild;　　//如果节点为已知节点的第一个子节点就可以使用这个方法。此方法可以递归进行使用 parentObj.firstChild.firstChild…..</p><p>parentObj.lastChild;　　//获得一个节点的最后一个节点，与firstChild一样也可以进行递归使用 parentObj.lastChild.lastChild…..</p><p>parentObj.childNodes;  //获得节点的所有子节点，然后通过循环和索引找到目标节点 </p><p><strong>获取相邻的节点</strong></p><p>curtNode.previousSibling; //获取已知节点的相邻的上一个节点</p><p>curtNode.nextSlbling;　　 // 获取已知节点的下一个节点</p><p><strong>获取父节点</strong></p><p>childNode.parentNode;　　//得到已知节点的父节点</p><p><strong>替换节点</strong></p><p>replace(newNode,oldNode);</p><h4 id="document-load-和-ready-的区别"><a href="#document-load-和-ready-的区别" class="headerlink" title="document load 和 ready 的区别"></a>document load 和 ready 的区别</h4><p>load 是当前页面所有资源加载完成后（包括DOM文档树，css文件，js文件，图片资源等），执行的一个函数，<br>问题： 如果图片资源较多，加载时间较长，onload 后等待执行的函数需要等待较长时间，所以一些效果可能受到影响。<br>$(document).ready() 是当DOM 文档树加载完成后执行的一个函数（不包含图片，css 等），所以会比load 较快执行。<br>在原生的js 中不包括ready() 这个方法，只有load 方法就是onload 事件。</p><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="== 和 === 的区别"></a><code>==</code> 和 <code>===</code> 的区别</h4><p>简单来说： == 代表相同， ===代表严格相同, 为啥这么说呢， </p><p>这么理解： 当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行===比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而===比较时， 如果类型不同，直接就是false.</p><p>操作数1 == 操作数2， 操作数1 === 操作数2</p><p>比较过程：</p><p>　　双等号==： </p><p>　　（1）如果两个值类型相同，再进行三个等号(===)的比较</p><p>　　（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p><p>　　　　1）如果一个是null，一个是undefined，那么相等</p><p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</p><p>　　三等号===:</p><p>　　（1）如果类型不同，就一定不相等</p><p>　　（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）</p><p>　　（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p><p>　　（4）如果两个值都是true，或是false，那么相等</p><p>　　（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p><p>　　（6）如果两个值都是null，或是undefined，那么相等</p><h4 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h4><p>function xxx(){}表示函数声明，可以放在代码的任何位置，也可以在任何地方成功调用；</p><p>var xxx = function(){};表示函数表达式，即将一个匿名函数赋值给一个变量，实现通过变量来调用这个匿名函数，但它需要在声明过后才能进行调用，如果调用在声明之前就会报如上红色字体的错误。而这在函数声明中不会出现这样的错误。</p><ul><li>将变量声明提升，只提升变量，不提升所赋的值；</li><li><p>将函数声明及函数内容提升，既提升函数声明，又提升函数内容，可以理解为将整个function内容提升；</p><p>函数声明和函数表达式相比，函数声明使用可以更加自由，可以放在随意的位置，因为它能够整体的变量提升； </p><p>而函数表达式使用就相对没有那么自由了，调用必须在声明的后面，因为变量提前只是将表达式的变量提前，并没有将表达式的内容提前。 </p></li></ul><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p><strong>首选ES6 提供新数据结构 Set</strong>   </p><p>var arr1=Array.from(new Set(arr))</p><p>var arr1 =[… new Set(arr)]</p><h4 id="JavaScript-创建对象的几种方式？"><a href="#JavaScript-创建对象的几种方式？" class="headerlink" title="JavaScript 创建对象的几种方式？"></a>JavaScript 创建对象的几种方式？</h4><p><strong>1、使用对象字面量创建</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Person = &#123;</span><br><span class="line">  name:&apos;小白&apos;,</span><br><span class="line">  age:23,</span><br><span class="line">  say: function() &#123;</span><br><span class="line">    console.log(&apos;我是：&apos; + this.name); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.say();  // 我是：小白</span><br></pre></td></tr></table></figure><p>使用同一个接口创建很多对象，会产生大量的重复代码。比如我想再创建一个Person2对象，我就得把上面的代码再重新写一遍，改变不同的属性值</p><p><strong>2、使用工厂模式创建对象</strong> </p><p>工厂模式抽象了创建具体对象的过程。由于在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, job) &#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.say = function() &#123;</span><br><span class="line">    console.log(&apos;say&apos; )</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createPerson(&apos;name&apos;,29)</span><br><span class="line">person1.say();</span><br></pre></td></tr></table></figure><p>函数createPerson()能够根据接受到的参数来构建一个包含所有必要信息的Person对象。可以无数次的调用这个函数，而每次它都会返回一个包含三个属性和一个方法的对象。<br>缺点：工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）</p><p>创建createPerson的时候，返回的是一个对象，那么我们就无法判断返回的对象究竟是一个什么样的类型。于是出现了使用构造函数创建对象。 </p><p><strong>3、使用构造函数创建对象</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.say = function() &#123;</span><br><span class="line">  console.log(this.name + &apos;:&apos; + this.age + &apos;岁&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;小白&apos;, &apos;12&apos;);</span><br><span class="line">person1.say();     // 小白:12岁</span><br><span class="line">var person2 =  new Person(&apos;小花&apos;, &apos;11&apos;);</span><br><span class="line">person2.say();     // 小花:11岁</span><br></pre></td></tr></table></figure><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。而这正是构造函数模式胜过工厂模式的地方。<br>然而，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在上面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例，创建两个完成同样任务的Function实例的确没有必要<br><strong>4、原型模式</strong></p><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有的对象实例共享他所包含的属性和方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;zhang&apos;;</span><br><span class="line">Person.prototype.age = &apos;22&apos;;</span><br><span class="line">Person.prototype.job = &apos;html5&apos;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br></pre></td></tr></table></figure><p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由共享的本性所导致的。<br>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说的过去，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然后，对于包含引用类型的属性来说，问题就比较突出了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype  = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    name:&apos;zhang&apos;,</span><br><span class="line">    age :&apos;22&apos;,</span><br><span class="line">    job :&apos;html5&apos;,</span><br><span class="line">    friends:[&apos;wang&apos;,&apos;li&apos;],</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(&apos;zhao&apos;);</span><br><span class="line">alert(person1.friends);  //&apos;wang,li,zhao&apos;</span><br><span class="line">alert(person2.friends); //&apos;wang,li,zhao&apos;</span><br><span class="line">alert(person1.friends === person2.friends);  //true</span><br></pre></td></tr></table></figure><p>从上面的打印的结果我们就可以知道为什么很少人单独使用原型模式了，实例一般都是要有属于自己的全部属性的。</p><p><strong>5、组合使用构造函数模式和原型模式</strong></p><p>组合使用构造函数模式和原型模式，是创建自定义类型的最常见方式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name= name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&apos;wang&apos;,&apos;li&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&apos;zhang&apos;,26,&apos;java&apos;,);</span><br><span class="line">var person2 = new Person(&apos;sun&apos;,25,&apos;php&apos;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&apos;zhao&apos;);</span><br><span class="line">alert(person1.friends);  //&apos;wang,li,zhao&apos;</span><br><span class="line">alert(person2.friends); //&apos;wang,li&apos;</span><br><span class="line">alert(person1.friends === person2.friends);  //false</span><br></pre></td></tr></table></figure><p>在上面的例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法satName()则是在原型中定义的。而修改了person1.friends(向其中添加一个新字符串)，并不会影响到person2.friends，因为他们分别引用了不同的数组。</p><h4 id="document-write-和innerHTML的区别"><a href="#document-write-和innerHTML的区别" class="headerlink" title="document.write()和innerHTML的区别"></a>document.write()和innerHTML的区别</h4><p>主要区别：document.write是直接将内容写入页面的内容流，会导致页面全部重绘，</p><p>innerHTML将内容写入某个DOM节点，不会导致页面全部重绘 </p><h4 id="js原型和原型链都是什么？"><a href="#js原型和原型链都是什么？" class="headerlink" title="js原型和原型链都是什么？"></a>js原型和原型链都是什么？</h4><p> <strong>实例的构造函数属性（constructor）=&gt; 指向构造函数。</strong> </p><p><strong>实例的隐式原型指向它构造函数的显式原型，指向的意思是恒等于</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例.__proto__ === 构造函数.prototype</span><br></pre></td></tr></table></figure><p><strong>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的<strong>proto</strong>属性中调用查找，也就是它构造函数的prototype中调用查找</strong>。 </p><p><strong>什么是原型链？</strong></p><p>原型链的核心就是依赖对象的<strong><strong> proto </strong></strong>的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有<strong> proto </strong>指向了。</p><p><strong>如何分析原型链?</strong></p><p>因为<strong>_ _proto </strong>实质找的是prototype，所以我们只要找这个链条上的构造函数的prototype。其中Object.prototype是没有 <strong> proto </strong> 属性的，等于null。</p><ul><li>所有引用类型都有一个<code>__proto__</code>(隐式原型)属性，属性值是一个普通的对象</li><li>所有函数都有一个prototype(原型)属性，属性值是一个普通的对象</li><li>所有引用类型的<code>__proto__</code>属性指向它构造函数的prototype</li></ul><p>函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址<br>函数的原型对象<strong>proto</strong>：所有对象都有<strong>proto</strong>属性， 当用构造函数实例化（new）一个对象时，会将新对象的<strong>proto</strong>属性指向 构造函数的prototype</p><p>原型链：原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<strong>proto</strong>隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的<strong>proto</strong>中查找，这样一层一层向上查找就会形成一个链式结构</p><p><strong>原型与原型链的常见面试题</strong></p><p><strong>谈谈你对原型的理解</strong>？<br>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法</p><p>什么是原型链？原型链解决的是什么问题？<br>1）原型链解决的主要是继承问题<br>2）每个对象拥有一个原型对象，通过 prototype 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.<strong> proto </strong>指向的是null)。这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法<br>3）构造函数 Parent、原型对象Parent.prototype 和 实例 p 的关系如下:(p. _ proto __ === Parent.prototype)</p><h4 id="js实现继承的方式"><a href="#js实现继承的方式" class="headerlink" title="js实现继承的方式"></a>js实现继承的方式</h4><p><strong>原型链继承</strong></p><p>我们只要把子类的prototype设置为父类的实例，就完成了继承，也就是js里面的原型链继承 </p><p>子类.prototype = new 父类(); </p><p>但是原型链继承有一个缺点，就是如果属性是引用类型的话，会共享引用类型 </p><p>当我们改变实例1的引用类型的属性时，实例2对应的属性也会跟着更改，这就是原型链继承的缺点—引用属性会被所有实例共享。 </p><p><strong>借用构造函数继承</strong></p><p> 这里跟原型链继承有个比较明显的区别是并没有使用prototype继承，而是在子类里面执行父类的构造函数。相当于把父类的代码复制到子类里面执行一遍，这样做的另一个好处就是可以给父类传参。 </p><p>构造函数解决了引用类型被所有实例共享的问题，但正是因为解决了这个问题，导致一个很矛盾的问题出现了—函数也是引用类型，也没办法共享了。也就是说，每个实例里面的函数，虽然功能一样，但是却不是一个函数，就相当于我们每实例化一个子类，就复制了一遍函数代码。 </p><table><thead><tr><th>继承方式</th><th>继承的核心代码</th><th>优缺点</th></tr></thead><tbody><tr><td>原型继承</td><td>Student.prototype = new Person()</td><td>实例的引用类型共享</td></tr><tr><td>构造函数继承</td><td>在子类(Student)里执行Person.call(this)</td><td>实例的引用类型不共享</td></tr></tbody></table><p><strong>组合继承</strong></p><p>普通属性使用构造函数继承，函数使用原型链继承 </p><p>这样我们就既能实现属性的独立，又能做到函数的共享。<br>至此，我们就把js里面的常用继承了解完了，总结一下：</p><p>1、原型链继承，会共享引用属性<br>2、构造函数继承，会独享所有属性，包括引用属性（重点是函数）<br>3、组合继承，利用原型链继承要共享的属性，利用构造函数继承要独享的属性，实现相对完美的继承<br>继承还有其他方式，比如原型式继承、寄生式继承、寄生组合继承等。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise的出现改变了JS的异步编程，现在基本上异步请求都是使用Promise实现。</p><p>Promise的出现主要是为了解决回调地狱的问题。</p><p>回调地狱就是多层嵌套的问题。 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性，需要多次异步请求的话，就会显得代码跳跃且乱。</p><p>具体的使用的话：</p><p>Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。</p><p>一个 Promise 实例有三种状态，分别是 pending、fulfilled 和 rejected，分别代表了进行中、成功和失败。实例的状态只能由进行中转变成功或者进行中转失败，并且状态一经改变，就无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。</p><p>Promise的原型上定义了一个 then 方法， 分别是成功和失败的回调。我们可以使用这个 then 方法可以为两个状态的改变注册回调函数。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;JavaScript-中有几种数据类型&quot;&gt;&lt;a href=&quot;#JavaScript-中有几种数据类型&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中有几种数据类型&quot;&gt;&lt;/a&gt;JavaScript 中有几种数据类型&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;基本数据类型&lt;/strong&gt;和&lt;strong&gt;引用数据类型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; 基本数据类型 ：&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt; 、&lt;code&gt;Null&lt;/code&gt;、&lt;code&gt;Undefined&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt;、&lt;code&gt;BigInt&lt;/code&gt; ; &lt;/p&gt;&lt;p&gt; 引用数据类型：&lt;code&gt;Object&lt;/code&gt;; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;不同类型的数据储存原理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;栈：原始数据类型（Undefined，Null，Boolean，Number、String）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>前端面试题整理（CSS篇）</title>
    <link href="http://yoursite.com/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88CSS%E7%AF%87%EF%BC%89/"/>
    <id>http://yoursite.com/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88CSS%E7%AF%87%EF%BC%89/</id>
    <published>2021-06-10T17:28:57.000Z</published>
    <updated>2021-06-28T13:39:42.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h4 id="介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同"><a href="#介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同" class="headerlink" title="介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同"></a>介绍一下标准的<code>css</code>的盒子模型？低版本IE的盒子模型有什么不同</h4><p> 一个基本的盒模型，包括<code>content(width/height)</code>，<code>padding</code>，<code>border</code>，<code>margin</code> </p><p> 有两种盒子模型，<code>IE</code>盒模型和<code>W3C</code>标准盒模型，</p><p>两者的区别：<code>W3C</code>标准盒模型，宽高是只有内容<code>content</code>，没有<code>padding</code>和<code>border</code>的， 而<code>IE</code>盒模型，宽高不光有<code>content</code>，还包含了<code>padding</code>和<code>border</code></p><a id="more"></a><p>怎么设置<code>w3c</code>盒模型和<code>ie</code>盒模型？           </p><p><code>box-sizing</code>用来控制元素的盒子模型的解析模式 </p><p><code>box-sizing: content-box</code>;　　// <code>W3C</code>标准盒模型（默认情况下）</p><p><code>box-sizing: border-box</code>;　　// <code>IE</code>盒模型</p><p>（这个也比较好记，标准的就是只有内容，就是<code>content</code>，而<code>IE</code>就是有<code>border</code>的）</p><h4 id="display-none与visibility-hidden的区别？"><a href="#display-none与visibility-hidden的区别？" class="headerlink" title="display:none与visibility:hidden的区别？"></a><code>display:none</code>与<code>visibility:hidden</code>的区别？</h4><p><code>display</code>: 隐藏对应的元素但不挤占该元素原来的空间。 </p><p><code>visibility</code>: 隐藏对应的元素并且挤占该元素原来的空间。 </p><h4 id="为什么要初始化样式-？"><a href="#为什么要初始化样式-？" class="headerlink" title="为什么要初始化样式 ？"></a>为什么要初始化样式 ？</h4><p> 由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异但是初始化<code>CSS</code>会对搜索引擎优化造成小影响。</p><h4 id="CSS选择符有哪些？"><a href="#CSS选择符有哪些？" class="headerlink" title="CSS选择符有哪些？"></a>CSS选择符有哪些？</h4><ul><li><code>id</code>选择器(<code>#myid</code>)</li><li>类选择器(<code>.myclassName</code>)</li><li>标签选择器(<code>div,h1,p</code>)</li><li>子代选择器(<code>ul&gt;li</code>)</li><li>后代选择器(<code>li a</code>)</li><li>多元素选择器(<code>div,p</code>)同时选择多种元素</li><li>相邻选择器(<code>div+p</code>) 选择相邻兄弟的第一个元素</li><li>兄弟选择器(<code>div~p</code>)选择相邻的所有兄弟<code>p</code>元素</li><li>通配符选择器(<code>*</code>)</li><li>属性选择器(<code>a[rel=&quot;external&quot;]</code>)</li><li>伪类选择器(<code>a:hover,li:nth-child</code>)</li></ul><h4 id="为什么需要清浮动？清浮动的方式"><a href="#为什么需要清浮动？清浮动的方式" class="headerlink" title="为什么需要清浮动？清浮动的方式"></a>为什么需要清浮动？清浮动的方式</h4><p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，就需要在该元素中清除浮动，准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong>。</p><p>清浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使页面后面的布局不能正常显示</p><ul><li>父级<code>div</code>定义<code>height</code></li><li>在浮动元素后面添加<code>class</code>为<code>clear</code>的空<code>div</code>元素，给这个div设置样式<code>.clear{clear:both}</code></li><li>给父容器添加<code>overflow:hidden</code>或者<code>auto</code>样式</li><li>给父容器添加<code>clearfix</code>的<code>class</code>，用伪类<code>clearfix:after</code>；来这个样式。清除浮动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    <span class="attribute">zoom</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'.'</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是外边距合并"><a href="#什么是外边距合并" class="headerlink" title="什么是外边距合并"></a>什么是外边距合并</h4><p>外边距合并指的是，当两个垂直外边距相遇时，他们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中较大者 </p><h4 id="如何获取盒子的宽高？"><a href="#如何获取盒子的宽高？" class="headerlink" title="如何获取盒子的宽高？"></a>如何获取盒子的宽高？</h4><p> 我们用得最多的就是<code>dom.offsetWidth  dom.offsetHeight</code>，这个包含了<code>width/height</code>，<code>padding</code>和<code>border</code>，是项目中最常用的，兼容性也最好，记住这个就行了 </p><h4 id="列举一些常用的伪类或伪元素？"><a href="#列举一些常用的伪类或伪元素？" class="headerlink" title="列举一些常用的伪类或伪元素？"></a>列举一些常用的伪类或伪元素？</h4><p><strong>伪类</strong>：（大部分都是<code>CSS3</code>里新增的）</p><p>: <code>hover</code> 鼠标hover</p><p>: <code>nth-child(n)</code>  选中父元素下的第<code>n</code>个子元素</p><p>: <code>not()</code>  不是什么什么</p><p>: <code>first-child</code>  第一个子元素</p><p>: <code>last-child</code>  最后一个子元素</p><p>: <code>checked</code>  单选框或复选框被选中的</p><p><strong>伪元素</strong>：</p><p>:: <code>before</code></p><p>:: <code>after</code></p><h4 id="选择器权重计算比较？"><a href="#选择器权重计算比较？" class="headerlink" title="选择器权重计算比较？"></a>选择器权重计算比较？</h4><p>一般讨论四种选择器：</p><p>元素或伪元素(::)  （x，x，x，0）</p><p>class选择符或伪类(:)   （x，x，0，x）</p><p>id选择符  （x，0，x，x）</p><p>标签内选择符  （0，x，x，x）</p><p>通常计算方法就是每出现一个，就在对应的权位上加<code>1</code>，不可进位，两个选择器比较权重就是从首位开始比较，数字相同的话就比较下一个。</p><p><code>!important</code>权位最高，不在讨论范围内，可以理解为  （1，x，x，x，x）</p><p>相同都有<code>!important</code>，就看谁在后面</p><h4 id="如何居中一个div？"><a href="#如何居中一个div？" class="headerlink" title="如何居中一个div？"></a>如何居中一个div？</h4><p><strong>水平居中：利用margin属性</strong></p><p> 给 <code>div</code> 设置一个宽高，然后添加 <code>margin:0 auto</code> 属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; </span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>; </span><br><span class="line"><span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">margin:0 auto;//上下为0 左右自适应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>水平垂直居中</strong></p><p>让left和top都是50%，这在水平方向上让div的最左与屏幕的最左相距50%，垂直方向上一样，所以再用transform向左（上）平移它自己宽度（高度）的50%，也就达到居中效果了 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>:-<span class="number">100px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">150px</span>;<span class="comment">/*或者下面一样效果*/</span></span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用flex弹性盒子</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>; <span class="comment">/*垂直方向居中*/</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;  <span class="comment">/*水平方向居中*/</span></span><br></pre></td></tr></table></figure><h4 id="CSS中定位的方式有哪些？position属性的值有哪些？"><a href="#CSS中定位的方式有哪些？position属性的值有哪些？" class="headerlink" title="CSS中定位的方式有哪些？position属性的值有哪些？"></a>CSS中定位的方式有哪些？position属性的值有哪些？</h4><ul><li>默认值：initial（浏览器默认值）</li><li>继承父级元素的定位机制：inherit</li><li>默认：static</li><li>相对定位：relative</li><li>绝对定位：absolute（注意<code>z-index</code>）</li><li>固定定位：fixed</li><li><p>粘性定位：sticky该定位基于用户滚动的位置。</p></li><li><p><strong>initial</strong>：设置该属性为浏览器默认值</p></li><li><p><strong>inherit</strong> ：规定应该从父元素继承 position 属性的值。</p></li></ul><ul><li><p>static</p><p> ：默认值。</p><ul><li>没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 </li></ul></li><li><p>relative</p><p> ：生成相对定位的元素，相对于其正常位置进行定位。</p><ul><li>因此，“left:20” 会向元素的 LEFT 位置添加 20 像素。</li></ul></li><li><p>absolute</p><p>： 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p><ul><li>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li></ul></li><li><p>fixed</p><p> ：生成绝对定位的元素，相对于浏览器窗口进行定位。</p><ul><li>元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed旧版本IE不支持</li></ul></li><li><p>sticky</p><ul><li>粘性定位，该定位基于用户滚动的位置。（特定阈值指的是 top, right, bottom 或 left 之一）<ul><li>它的行为就像 position:relative; 而当页面滚动超出目标区域时，</li><li>它的表现就像 position:fixed;，它会固定在目标位置。</li><li>注意: Internet Explorer, Edge 15 及更早 IE 版本不支</li></ul></li></ul></li></ul><h4 id="display有哪些值？说明他们的作用"><a href="#display有哪些值？说明他们的作用" class="headerlink" title="display有哪些值？说明他们的作用"></a>display有哪些值？说明他们的作用</h4><p><strong>display 显示状态有:</strong></p><p><strong>none</strong> 隐藏，此元素不会被显示。</p><p><strong>block</strong> 块显示；此元素将显示为块级元素，此元素前后会带有换行符。</p><p><strong>inline</strong> 内嵌 ，默认。此元素会被显示为内联元素，元素前后没有换行符。</p><p><strong>table</strong> 表格显示，此元素会作为块级表格来显示（类似 <code></code>），表格前后带有换行符。</p><p><strong>inline-block</strong>：元素既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。</p><p><strong>list-item</strong>:象块类型元素一样显示，并添加样式列表标记。</p><p><strong>inherit</strong> 规定应该从父元素继承 display 属性的值</p><h4 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h4><ul><li>CSS3实现圆角（border-radius），阴影（box-shadow），</li><li>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li><li>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</li><li>增加了更多的CSS选择器  多背景 rgba </li><li>在CSS3中唯一引入的伪元素是 <code>::selection</code>.</li><li>媒体查询，多栏布局</li><li>border-image</li></ul><h4 id="CSS3新增伪类有哪些？"><a href="#CSS3新增伪类有哪些？" class="headerlink" title="CSS3新增伪类有哪些？"></a>CSS3新增伪类有哪些？</h4><p>CSS3新增伪类举例：</p><ul><li>p:first-of-type 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素。</li><li>p:last-of-type 选择属于其父元素的最后<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素。</li><li>p:only-of-type 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-child  选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>:enabled、:disabled 控制表单控件的禁用状态。</li><li>:checked，单选框或复选框被选中。</li><li>:after 在元素之前添加内容,也可以用来做清除浮动。</li><li>:before 在元素之后添加内容</li><li>:enabled</li><li>:disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。</li></ul><h4 id="margin的上下左右四个数值？"><a href="#margin的上下左右四个数值？" class="headerlink" title="margin的上下左右四个数值？"></a>margin的上下左右四个数值？</h4><p>margin属性的四个值                                                   <strong>上  右  下  左</strong></p><p>如果有三个值，那左右相同（左取的是第二个值）   <strong>上     左右     下</strong></p><p>如果有两个值，那上下相同，左右相同                      <strong>上下   左右</strong></p><p>如果有一个值，那四面相同                                          <strong>上右下左</strong></p><h4 id="对line-height是如何理解的？"><a href="#对line-height是如何理解的？" class="headerlink" title="对line-height是如何理解的？"></a>对line-height是如何理解的？</h4><p>基线位置是由字体确定的，css的line-height指的是一行字的高度，包含了字间距，实际上就是下一行的基线到上一行的基线距离。</p><p>line-height的值跟height的值一样，字体就会垂直居中;</p><h4 id="解释下CSS-sprites是什么？"><a href="#解释下CSS-sprites是什么？" class="headerlink" title="解释下CSS sprites是什么？"></a>解释下CSS sprites是什么？</h4><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中， 将多个⼩图⽚拼接到⼀个图⽚中。通过 background-position 和元素尺⼨调节需要显示的背景图案。 </p><p>再利用 CSS 的”background-image”，“background-repeat”，“background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。</p><p>这样可以减少很多图片请求的开销，因为请求耗时比较长；</p><h4 id="抽离样式模块怎么写，说出思路，有无实践经验？"><a href="#抽离样式模块怎么写，说出思路，有无实践经验？" class="headerlink" title="抽离样式模块怎么写，说出思路，有无实践经验？"></a>抽离样式模块怎么写，说出思路，有无实践经验？</h4><p>首一个成熟的网站需要有统一的风格，一致的用户体验，比如：网站的配色，字体的大小，交互行为一致等应该在设计之初就得到确定，而不是由个体开发者来自由的定义。</p><p>网站同时应存在可以提取出来公用的样式部分。那么我们就可以把网站的字体大小，公共控制，共用模块的样式都抽离出来，作为单独的模块来处理。</p><p>这样，团队中的每个人如果需要这样的样式，都可以用这种公共样式，以此提高代码的重用率。</p><p>我认为一个项目的CSS可以拆分成2部分：公共CSS和业务CSS。</p><p>我们在项目中抽出的这部分可以模块化的CSS就可以归类为公共CSS。</p><p>这部分的代码命名不应涉及到具体的业务，只应对其在模块中负责的具体逻辑负责。</p><p>对于业务CSS，我们需要有统一的命名。如一个网站中有如下几个栏目：文件，社区，社交关系等，在项目规划时，就需要把这块模块的名称定好，</p><p>比如 文件-files,社区-cmty(community简写)，这样开发人员在写样式时，就可以使用公用的前缀，.cmty-cmtydetail，而不会根据各自的想法，</p><p>写成.community或是.commu，这一点对于统一风格是尽为重要的，也方便备用人员接手工作。</p><h4 id="base64有什么好处，base64有什么缺点？"><a href="#base64有什么好处，base64有什么缺点？" class="headerlink" title="base64有什么好处，base64有什么缺点？"></a>base64有什么好处，base64有什么缺点？</h4><p>什么时候用，一般移动端的大的背景图会用base64，而且图片体积比较大的时候才会用base64；</p><p>如果图片比较小，那么base64编码后的字符串会比图片本身还大，只有图片打到几百K的时候，</p><p>用base64编码会大大缩小图片的体积；</p><p><strong>优点</strong>：能够减小大图片的尺寸，同时还能够减少HTTP请求数量；HTTP请求是非常耗费服务器资源的；</p><h4 id="JS为什么会放在下面，CSS为什么放在上面"><a href="#JS为什么会放在下面，CSS为什么放在上面" class="headerlink" title="JS为什么会放在下面，CSS为什么放在上面"></a>JS为什么会放在下面，CSS为什么放在上面</h4><p>浏览器从上到下依次解析html文档。</p><p>将 css 文件放到头部， css 文件可以先加载。避免先加载 body 内容，导致页面一开始样式错乱，然后闪烁。</p><p>将 javascript 文件放到底部是因为：若</p><p>将 javascript 文件放到 head 里面，就意味着必须等到所有的 javascript 代码都被 下载、解析和执行完成 之后才开始呈现页面内容。</p><p>这样就会造成呈现页面时出现明显的延迟，窗口一片空白。</p><p>为避免这样的问题一般将全部 javascript 文件放到 body 元素中页面内容的后面。</p><h4 id="rgba-和opacity的透明效果有什么不同？"><a href="#rgba-和opacity的透明效果有什么不同？" class="headerlink" title="rgba()和opacity的透明效果有什么不同？"></a>rgba()和opacity的透明效果有什么不同？</h4><ul><li>rgba() 和 opacity 都能实现透明效果，但最⼤的不同是 opacity 作⽤于元素，以及元素内的所有内容的透明度，</li><li>⽽ rgba() 只作⽤于元素的颜⾊或其背景⾊。（设置 rgba 透明的元素的⼦元素不会继承透明效果！</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;&lt;h4 id=&quot;介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同&quot;&gt;&lt;a href=&quot;#介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同&quot; class=&quot;headerlink&quot; title=&quot;介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同&quot;&gt;&lt;/a&gt;介绍一下标准的&lt;code&gt;css&lt;/code&gt;的盒子模型？低版本IE的盒子模型有什么不同&lt;/h4&gt;&lt;p&gt; 一个基本的盒模型，包括&lt;code&gt;content(width/height)&lt;/code&gt;，&lt;code&gt;padding&lt;/code&gt;，&lt;code&gt;border&lt;/code&gt;，&lt;code&gt;margin&lt;/code&gt; &lt;/p&gt;&lt;p&gt; 有两种盒子模型，&lt;code&gt;IE&lt;/code&gt;盒模型和&lt;code&gt;W3C&lt;/code&gt;标准盒模型，&lt;/p&gt;&lt;p&gt;两者的区别：&lt;code&gt;W3C&lt;/code&gt;标准盒模型，宽高是只有内容&lt;code&gt;content&lt;/code&gt;，没有&lt;code&gt;padding&lt;/code&gt;和&lt;code&gt;border&lt;/code&gt;的， 而&lt;code&gt;IE&lt;/code&gt;盒模型，宽高不光有&lt;code&gt;content&lt;/code&gt;，还包含了&lt;code&gt;padding&lt;/code&gt;和&lt;code&gt;border&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>前端面试题整理(HTML篇)</title>
    <link href="http://yoursite.com/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</id>
    <published>2021-06-10T16:50:52.000Z</published>
    <updated>2021-06-10T17:39:16.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h4 id="doctype-⽂档类型-的作用是什么？"><a href="#doctype-⽂档类型-的作用是什么？" class="headerlink" title="doctype(⽂档类型)的作用是什么？"></a><code>doctype</code>(⽂档类型)的作用是什么？</h4><p>位于文档第一行，告知浏览器文档使用哪种 HTML 规范。告诉浏览器按照何种规范解析页面 </p><h4 id="常用的浏览器以及内核都是什么"><a href="#常用的浏览器以及内核都是什么" class="headerlink" title="常用的浏览器以及内核都是什么"></a>常用的浏览器以及内核都是什么</h4><p>IE: trident</p><p>Firefox：gecko  </p><p>Safari:webkit </p><p>Opera: Blink </p><p>Chrome:Blink</p><h4 id="img标签的title和alt有什么区别？"><a href="#img标签的title和alt有什么区别？" class="headerlink" title="img标签的title和alt有什么区别？"></a><code>img</code>标签的<code>title</code>和<code>alt</code>有什么区别？</h4><a id="more"></a><p><code>title</code>属性是对图片的描述与进一步说明，会在鼠标移到元素上时显示一段提示文本 </p><p> <code>alt</code>属性是当图片无法显示的时候的替代文本</p><h4 id="描述一下渐进增强和优雅降级之间的不同"><a href="#描述一下渐进增强和优雅降级之间的不同" class="headerlink" title="描述一下渐进增强和优雅降级之间的不同 ?"></a>描述一下渐进增强和优雅降级之间的不同 ?</h4><p> 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 </p><p>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 。</p><h4 id="谈一下你对网页标准和标准制定机构重要性的理解"><a href="#谈一下你对网页标准和标准制定机构重要性的理解" class="headerlink" title="谈一下你对网页标准和标准制定机构重要性的理解"></a>谈一下你对网页标准和标准制定机构重要性的理解</h4><p>网页标准和标准制定机构都是为了能让<code>web</code>发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO 也会更好做不会因为滥用代码导致各种<code>BUG</code>、安全问题， 最终提高网站易用性 </p><h4 id="描述一下cookies，sessionStorage和-localStorage的区别"><a href="#描述一下cookies，sessionStorage和-localStorage的区别" class="headerlink" title="描述一下cookies，sessionStorage和 localStorage的区别"></a>描述一下<code>cookies</code>，<code>sessionStorage</code>和 <code>localStorage</code>的区别</h4><p><code>sessionStorage</code>中的数据， 数据在当前浏览器窗⼝关闭后⾃动删除</p><p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</p><p><code>sessionStorage</code>和<code>localStorage</code>不会⾃动把数据发给服务器，仅在本地保存 </p><p><code>cookie</code>数据⼤⼩不能超过<code>4k</code> </p><p><code>sessionStorage</code>和<code>localStorage</code> 虽然也有存储⼤⼩的限制，但⽐<code>cookie</code>⼤得 多，可以达到<code>5M</code>或更⼤ </p><h4 id="src与href的区别？"><a href="#src与href的区别？" class="headerlink" title="src与href的区别？"></a><code>src</code>与<code>href</code>的区别？</h4><p><code>src</code>用于替代这个元素，而<code>href</code>用于建立这个标签与外部资源之间的关系。</p><p> <strong>src (Source)源</strong>这个属性是将资源嵌入到当前文档中元素所在的位置。 在请求<code>src</code>资源时会将其指向的资源下载并应用到当前文档中 </p><p> <strong>href</strong>这个属性指定<code>web</code>资源的位置，从而定义当前元素或当前文档与目标资源之间的联系。 </p><h4 id="一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验?"></a>一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验?</h4><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p><p> 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先 下载。 </p><p>使用 CSSsprite，Iconfont技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图， 以提高用户体验。 </p><h4 id="语义化的理解"><a href="#语义化的理解" class="headerlink" title="语义化的理解"></a>语义化的理解</h4><p>就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式 CSS 情况下也以⼀种⽂档格式显示，容易阅读。 搜索引擎的爬⾍依赖于标记来确定上下⽂和各个关键字的权重，利于 SEO 。 </p><h4 id="HTML块元素标签、行内元素标签都有哪些？"><a href="#HTML块元素标签、行内元素标签都有哪些？" class="headerlink" title="HTML块元素标签、行内元素标签都有哪些？"></a><code>HTML</code>块元素标签、行内元素标签都有哪些？</h4><p>块级元素 div  p  ul  li  table  h1 h2 h3 … h6  form 等  可以设置宽高  独占一行</p><p>行内元素 span  a  i  label  img  input  button  textarea select 等   不能设置宽高 不独占一行</p><p>行内块元素  综合了行内元素和块状元素的特性   就是不独占一行的块级元素 </p><h4 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h4><ul><li><p>用于绘画的 canvas 元素</p></li><li><p>用于媒介回放的 video 和 audio 元素</p></li><li>对本地离线存储的更好的支持</li><li>新的特殊内容元素，比如 article、footer、header、nav、section</li><li>新的表单控件，比如 calendar、date、time、email、url、search</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h4 id=&quot;doctype-⽂档类型-的作用是什么？&quot;&gt;&lt;a href=&quot;#doctype-⽂档类型-的作用是什么？&quot; class=&quot;headerlink&quot; title=&quot;doctype(⽂档类型)的作用是什么？&quot;&gt;&lt;/a&gt;&lt;code&gt;doctype&lt;/code&gt;(⽂档类型)的作用是什么？&lt;/h4&gt;&lt;p&gt;位于文档第一行，告知浏览器文档使用哪种 HTML 规范。告诉浏览器按照何种规范解析页面 &lt;/p&gt;&lt;h4 id=&quot;常用的浏览器以及内核都是什么&quot;&gt;&lt;a href=&quot;#常用的浏览器以及内核都是什么&quot; class=&quot;headerlink&quot; title=&quot;常用的浏览器以及内核都是什么&quot;&gt;&lt;/a&gt;常用的浏览器以及内核都是什么&lt;/h4&gt;&lt;p&gt;IE: trident&lt;/p&gt;&lt;p&gt;Firefox：gecko  &lt;/p&gt;&lt;p&gt;Safari:webkit &lt;/p&gt;&lt;p&gt;Opera: Blink &lt;/p&gt;&lt;p&gt;Chrome:Blink&lt;/p&gt;&lt;h4 id=&quot;img标签的title和alt有什么区别？&quot;&gt;&lt;a href=&quot;#img标签的title和alt有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;img标签的title和alt有什么区别？&quot;&gt;&lt;/a&gt;&lt;code&gt;img&lt;/code&gt;标签的&lt;code&gt;title&lt;/code&gt;和&lt;code&gt;alt&lt;/code&gt;有什么区别？&lt;/h4&gt;</summary>
    
    
    
    <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue常见面试题总结</title>
    <link href="http://yoursite.com/2020/01/13/vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/13/vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-13T07:23:21.000Z</published>
    <updated>2020-01-14T07:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是MVVM？"><a href="#一、什么是MVVM？" class="headerlink" title="一、什么是MVVM？"></a><strong>一、什么是MVVM？</strong></h1><p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p><a id="more"></a><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><h1 id="二、vue的优点是什么？"><a href="#二、vue的优点是什么？" class="headerlink" title="二、vue的优点是什么？"></a>二、vue的优点是什么？</h1><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p><p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p><p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p><h1 id="三、组件之间的传值？"><a href="#三、组件之间的传值？" class="headerlink" title="三、组件之间的传值？"></a>三、组件之间的传值？</h1><ul><li><p>父组件通过标签上<code>:data=data</code>方式定义传值</p></li><li><p>子组件通过<code>props</code>方法接受数据</p></li><li><p>子组件通过<code>$emit</code>方法传递参数</p><!-- more !--></li></ul><h1 id="四、vuex面试相关"><a href="#四、vuex面试相关" class="headerlink" title="四、vuex面试相关"></a>四、vuex面试相关</h1><p>（1）vuex是什么？怎么使用？哪种功能场景使用它？</p><p>vue框架中状态管理。在main.js引入store注入。新建一个目录store 。场景有：单页应用中，组件之间的状态，音乐播放、登录状态、加入购物车等。</p><h2 id="（2）vuex有哪几种属性？"><a href="#（2）vuex有哪几种属性？" class="headerlink" title="（2）vuex有哪几种属性？"></a>（2）vuex有哪几种属性？</h2><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module。</p><h2 id="（3）-vuex的State特性"><a href="#（3）-vuex的State特性" class="headerlink" title="（3） vuex的State特性"></a>（3） vuex的State特性</h2><p>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。</p><p>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。</p><p>通过mapState把全局 state 和 getters 映射到当前组件的 computed 计算属性中。</p><h2 id="（4）vuex的Getter特性"><a href="#（4）vuex的Getter特性" class="headerlink" title="（4）vuex的Getter特性"></a>（4）vuex的Getter特性</h2><p>getters 可以对State进行计算操作，它就是Store的计算属性。</p><p>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。</p><p>如果一个状态只在一个组件内使用，可以不用getters。</p><h2 id="（5）vuex的Mutation特性"><a href="#（5）vuex的Mutation特性" class="headerlink" title="（5）vuex的Mutation特性"></a>（5）vuex的Mutation特性</h2><p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p><h2 id="（6）不用Vuex会带来什么问题？"><a href="#（6）不用Vuex会带来什么问题？" class="headerlink" title="（6）不用Vuex会带来什么问题？"></a>（6）不用Vuex会带来什么问题？</h2><p>可维护性会下降，想修改数据要维护三个地方；</p><p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p><p>增加耦合，大量的上传派发，会让耦合性大大增加，Vue用Component本意就是为了减少耦合，现在这么用，和组件化的初衷相背。</p><h1 id="五、v-show和v-if指令的共同点和不同点"><a href="#五、v-show和v-if指令的共同点和不同点" class="headerlink" title="五、v-show和v-if指令的共同点和不同点"></a>五、v-show和v-if指令的共同点和不同点</h1><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏；</p><p>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果；</p><p>使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p><h1 id="六、请列举出3个Vue中常用的生命周期钩子函数"><a href="#六、请列举出3个Vue中常用的生命周期钩子函数" class="headerlink" title="六、请列举出3个Vue中常用的生命周期钩子函数"></a>六、请列举出3个Vue中常用的生命周期钩子函数</h1><p>created: 实例创建完成之后调用，在这一步，实例已经完成数据观测、 属性和方法的运算、watch/event事件回调。然而，挂载阶段还没有开始, $el属性目前还不可见。</p><p><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p><p>activated: keep-alive组件激活时调用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、什么是MVVM？&quot;&gt;&lt;a href=&quot;#一、什么是MVVM？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是MVVM？&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、什么是MVVM？&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>src与href的区别</title>
    <link href="http://yoursite.com/2018/09/10/src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/09/10/src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-09-10T07:46:55.000Z</published>
    <updated>2018-09-10T07:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p> src和href都是用于外部资源的引入，像图片、CSS文件、HTML文件、js文件或其他web页面等。 </p><p>引用css文件时：<code>href=&quot;cssfile.css&quot;</code> </p><p>引用js文件时：<code>src=&quot;myscript.js&quot;</code> </p><p>引用图片：<code>src=&quot;mypic.jpg&quot;</code> </p><a id="more"></a><p>网站链接：<code>href=&quot;http://www.webpage.com&quot;</code></p><p><strong>它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。</strong> </p><p> <strong>href (Hypertext Reference) 超文本引用</strong><code>href</code>这个属性指定<code>web</code>资源的位置，从而定义当前元素（如锚点<code>a</code>）或当前文档（如链接）与目标锚点或目标资源之间的联系。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure><p>浏览器知道这是个样式表文件，html的解析和渲染不会暂停，css文件的加载是同时进行的，这不同于在style标签里面的内置样式，用@import添加的样式是在页面载入之后再加载，这可能会导致页面因重新渲染而闪烁。所以我们建议使用<code>link</code>而不是<code>@import</code>。</p><h3 id="补充：link和-import的区别"><a href="#补充：link和-import的区别" class="headerlink" title="补充：link和@import的区别"></a>补充：<code>link</code>和@<code>import</code>的区别</h3><p>两者都是外部引用<code>CSS</code>的方式，但是存在一定的区别：</p><p>1、<code>link</code>是<code>XHTML</code>标签，除了加载<code>CSS</code>外，还可以定义<code>RSS</code>等其他事务；<code>@import</code>属于<code>CSS</code>范畴，只能加载<code>CSS</code>。</p><p>2、<code>link</code>引用<code>CSS</code>时，在页面载入时同时加载；@<code>import</code>需要页面网页完全载入以后加载。</p><p>3、<code>link</code>是<code>XHTML</code>标签，无兼容问题；@<code>import</code>是在<code>CSS2.1</code>提出的，低版本的浏览器不支持。</p><p>4、<code>link</code>支持使用<code>Javascript</code>控制<code>DOM</code>去改变样式；而<code>@import</code>不支持。</p><p> <strong>src (Source)源</strong>这个属性是将资源嵌入到当前文档中元素所在的位置。 在请求<code>src</code>资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。 例如当我们写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个<code>js</code>文件。这就像是把<code>js</code>文件里的内容全部注入到这个<code>script</code>标签中，类似于<code>img</code>，<code>img</code>标签是一个空标签，它的内容就是由<code>src</code>这个属性定义，浏览器会暂停加载直到这个图片加载完成。这也是为什么要将<code>js</code>文件的加载放在<code>body</code>最后的原因（在<code>&lt;body&gt;</code>前面）。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;src和href的区别&quot;&gt;&lt;a href=&quot;#src和href的区别&quot; class=&quot;headerlink&quot; title=&quot;src和href的区别&quot;&gt;&lt;/a&gt;src和href的区别&lt;/h2&gt;&lt;p&gt; src和href都是用于外部资源的引入，像图片、CSS文件、HTML文件、js文件或其他web页面等。 &lt;/p&gt;&lt;p&gt;引用css文件时：&lt;code&gt;href=&amp;quot;cssfile.css&amp;quot;&lt;/code&gt; &lt;/p&gt;&lt;p&gt;引用js文件时：&lt;code&gt;src=&amp;quot;myscript.js&amp;quot;&lt;/code&gt; &lt;/p&gt;&lt;p&gt;引用图片：&lt;code&gt;src=&amp;quot;mypic.jpg&amp;quot;&lt;/code&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://yoursite.com/2018/09/05/Vuex/"/>
    <id>http://yoursite.com/2018/09/05/Vuex/</id>
    <published>2018-09-05T01:59:26.000Z</published>
    <updated>2018-09-05T01:59:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vuex的基本介绍"><a href="#vuex的基本介绍" class="headerlink" title="vuex的基本介绍"></a><code>vuex</code>的基本介绍</h1><p><code>Vuex</code>是一个专门为<code>Vue.js</code>应用程序开发的状态管理模式。它采用集中式的存储管理应用所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变。 </p><p><code>vuex</code>是<code>vue</code>的状态管理工具，状态即数据， 状态管理就是管理<code>vue</code>中的数据。 </p><h4 id="vuex的优点"><a href="#vuex的优点" class="headerlink" title="vuex的优点"></a><code>vuex</code>的优点</h4><ul><li>可以用来解决组件通讯的问题</li><li><code>vuex</code>可以用来集中的管理<code>vue</code>项目中用到的所有数据（这并不意味着要将所有的数据都交给<code>vuex</code>进行管理）</li></ul><a id="more"></a><h4 id="为什么要使用vuex"><a href="#为什么要使用vuex" class="headerlink" title="为什么要使用vuex"></a>为什么要使用<code>vuex</code></h4><ul><li>在大型的项目中，组件通讯会变得很混乱，使用<code>vuex</code>可以统一的管理组件之间的通讯。并且可以通过开发者工具，追踪到变化。</li><li>当你要开发一个大型的<code>SPA</code>应用的时候，会出现：多个视图公用一个状态、不同视图的行为要改变同一个状态的情况，遇到这种情况的时候就需要考虑使用<code>Vuex</code>了，它会把组件的共享状态抽取出来，当做一个全局单例模式进行管理，这样不管你何时何地改变状态，都会通知到使用该状态的组件做出相应的修改；</li></ul><p><code>vuex</code>其实就是用一个全局的变量保存了<code>Vue</code>项目中的所有的公共数据，类似与在前端这块放了一个数据库，大家都可以在这里存数据，删数据，改数据，读数据，是不是有点熟悉：增，删，改，查；不过这个全局的变量给他定义了一个固定的名字就叫：<code>store</code>（仓库），是不是很形象，而这个仓库里面装数据的袋子就是<code>state</code>，加工数据的机器就叫做：<code>mutations</code>，操作机器的工人就叫做：<code>actions</code>，把数据装起来取走的卡车就叫做：<code>getters</code>;<br> 所以一个简单的<code>vuex</code>就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new vuex.store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vuex-特点"><a href="#Vuex-特点" class="headerlink" title="Vuex 特点"></a><code>Vuex</code> 特点</h3><ul><li><code>Vuex</code>的状态存储是响应式的。当<code>Vue</code>组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 <code>store</code> 中的状态。改变 <code>store</code> 中的状态的唯一途径就是显式地提交(<code>commit</code>) <code>mutations</code>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ul><h3 id="Vuex实例"><a href="#Vuex实例" class="headerlink" title="Vuex实例"></a><code>Vuex</code>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这就是一个<code>vuex</code>的最简单实例，<code>store</code>就是组件中的共享状态，而改变状态的方法(其实是一个对象包含很多方法，但都是来改变<code>store</code>的)叫做:<code>mutations</code>；<br> 需要特变注意的是只能通过<code>mutations</code>改变<code>store</code>的<code>state</code>的状态，不能通过<code>store.state.count = 5</code>;直接更改（其实可以更改，不建议这么做，不通过<code>mutations</code>改变<code>state</code>，状态不会被同步）。<br> 使用<code>store.commit</code>方法触发<code>mutations</code>改变<code>state</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;);</span><br><span class="line">console.log(store.state.count)  // 1</span><br></pre></td></tr></table></figure><p> 这样一个简简单单的Vuex应用就实现了。 </p><h3 id="在Vue组件里使用Vuex"><a href="#在Vue组件里使用Vuex" class="headerlink" title="在Vue组件里使用Vuex"></a>在<code>Vue</code>组件里使用<code>Vuex</code></h3><p> <code>Vuex</code>的状态获取是一个方法，当<code>Vuex</code>状态更新时，相应的<code>Vue</code>组件也要更新，所以<code>Vue</code>应该在计算属性（<code>computed</code>）获取<code>state</code>； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return store.state.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面的例子是直接操作全局状态<code>store.state.count</code>，那么每个使用该<code>Vuex</code>的组件都要引入。为了解决这个，<code>Vuex</code>通过<code>store</code>选项，提供了一种机制将状态从根组件注入到每一个子组件中。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 根组件</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    store,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Counter</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">            &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 通过这种注入机制，就能在子组件<code>Counter</code>通过<code>this.$store</code>访问： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return this.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mapState函数"><a href="#mapState函数" class="headerlink" title="mapState函数"></a><code>mapState</code>函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">        return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样通过<code>count</code>计算属性获取同名<code>state.count</code>属性，是不是显得太重复了，我们可以使用<code>mapState</code>函数简化这个过程。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: state =&gt; state.count,</span><br><span class="line">        countAlias: &apos;count&apos;,    // 别名 `count` 等价于 state =&gt; state.count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 还有更简单的使用方法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="Getters对象"><a href="#Getters对象" class="headerlink" title="Getters对象"></a><code>Getters</code>对象</h5><p> 如果我们需要对<code>state</code>对象进行做处理计算，如下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数。这样是很没有效率的事情，当这个处理过程更改了，还有在多个组件中进行同样的更改，这就更加不易于维护。</p><p><code>Vuex</code>中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理。<code>Getters</code>接受<code>state</code>作为第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 在<code>Vue</code>中通过<code>store.getters</code>对象调用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodos () &#123;</span><br><span class="line">    return this.$store.getters.doneTodos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>Getter</code>也可以接受其他<code>getters</code>作为第二个参数： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">  &#125;,</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;vuex的基本介绍&quot;&gt;&lt;a href=&quot;#vuex的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;vuex的基本介绍&quot;&gt;&lt;/a&gt;&lt;code&gt;vuex&lt;/code&gt;的基本介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Vuex&lt;/code&gt;是一个专门为&lt;code&gt;Vue.js&lt;/code&gt;应用程序开发的状态管理模式。它采用集中式的存储管理应用所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变。 &lt;/p&gt;&lt;p&gt;&lt;code&gt;vuex&lt;/code&gt;是&lt;code&gt;vue&lt;/code&gt;的状态管理工具，状态即数据， 状态管理就是管理&lt;code&gt;vue&lt;/code&gt;中的数据。 &lt;/p&gt;&lt;h4 id=&quot;vuex的优点&quot;&gt;&lt;a href=&quot;#vuex的优点&quot; class=&quot;headerlink&quot; title=&quot;vuex的优点&quot;&gt;&lt;/a&gt;&lt;code&gt;vuex&lt;/code&gt;的优点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;可以用来解决组件通讯的问题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vuex&lt;/code&gt;可以用来集中的管理&lt;code&gt;vue&lt;/code&gt;项目中用到的所有数据（这并不意味着要将所有的数据都交给&lt;code&gt;vuex&lt;/code&gt;进行管理）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue-router导航守卫</title>
    <link href="http://yoursite.com/2018/08/29/Vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"/>
    <id>http://yoursite.com/2018/08/29/Vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</id>
    <published>2018-08-29T07:38:56.000Z</published>
    <updated>2018-08-29T07:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><p> 其实，导航守卫就是路由跳转过程中的一些钩子函数，再直白点路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。 </p><a id="more"></a><p> <strong>导航守卫分为</strong>：全局的、单个路由独享的、组件内的三种。分别来看一下： </p><p><strong>【全局的】</strong>：是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数，如下的写法。钩子函数按执行顺序包括<code>beforeEach</code>、<code>beforeResolve</code>（2.5+）、<code>afterEach</code>三个（以下的钩子函数都是按执行顺序讲解的）： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> <strong>全局守卫</strong></p><p>[<code>beforeEach</code>]：在路由跳转前触发，参数包括<code>to</code>,<code>from</code>,<code>next</code>（参数会单独介绍）三个，这个钩子作用主要是用于登录验证，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚。 </p><p> [<code>beforeResolve</code>]（2.5+）：这个钩子和<code>beforeEach</code>类似，也是路由跳转前触发，参数也是<code>to</code>,<code>from</code>,<code>next</code>三个，和<code>beforeEach</code>区别官方解释为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</span><br></pre></td></tr></table></figure><p> 即在 <code>beforeEach</code> 和 组件内<code>beforeRouteEnter</code> 之后，<code>afterEach</code>之前调用。 </p><p> [<code>afterEach</code>]：和<code>beforeEach</code>相反，他是在路由跳转完成后触发，参数包括<code>to</code>,<code>from</code>没有了<code>next</code>（参数会单独介绍）,他发生在<code>beforeEach</code>和<code>beforeResolve</code>之后，<code>beforeRouteEnter</code>（组件内守卫，后讲）之前。 </p><p><strong>路由守卫</strong></p><p><code>beforeEnter</code></p><p><strong>组件守卫</strong></p><p><code>beforeRouteEnter</code></p><p>  // 在渲染该组件的对应路由被 confirm 前调用</p><p>  // 不！能！获取组件实例 <code>this</code></p><p>  // 因为当守卫执行前，组件实例还没被创建</p><p>  虽然无法直接获取组件实力</p><p>  但是我们可以通过next参数的回调函数获取到当前实例进行操作</p><p>  beforeRouteEnter: (to, from, next) =&gt; {</p><pre><code>next((vm) =&gt; {  //vm就是当前组件实例});</code></pre><p>  }</p><p><code>beforeRouteUpdate</code></p><p>  // 在当前路由改变，但是该组件被复用时调用</p><p>  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</p><p>  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</p><p>  // 可以访问组件实例 <code>this</code></p><p><code>beforeRouteLeave</code></p><p>  // 导航离开该组件的对应路由时调用</p><p>  // 可以访问组件实例 <code>this</code></p><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p><p>每个守卫方法接收三个参数：</p><ul><li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Froute-object.html" target="_blank" rel="noopener">路由对象</a></li><li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li><li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul><li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> （确认的）。</li><li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-link.html" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。</li><li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.onError()</code></a> 注册过的回调。</li></ul></li></ul><p><strong>确保要调用 <code>next</code> 方法，否则钩子就不会被 resolved。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;导航守卫&quot;&gt;&lt;a href=&quot;#导航守卫&quot; class=&quot;headerlink&quot; title=&quot;导航守卫&quot;&gt;&lt;/a&gt;导航守卫&lt;/h1&gt;&lt;p&gt;正如其名，&lt;code&gt;vue-router&lt;/code&gt; 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。&lt;/p&gt;&lt;p&gt; 其实，导航守卫就是路由跳转过程中的一些钩子函数，再直白点路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。 &lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中computed与watch的区别</title>
    <link href="http://yoursite.com/2018/08/16/Vue%E4%B8%ADcomputed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/16/Vue%E4%B8%ADcomputed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-08-16T15:16:13.000Z</published>
    <updated>2018-08-16T15:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="computed计算属性与watch的区别"><a href="#computed计算属性与watch的区别" class="headerlink" title="computed计算属性与watch的区别"></a><code>computed</code>计算属性与<code>watch</code>的区别</h3><p><code>computed</code>和<code>watch</code>都是观察页面的数据变化的。 </p><p><code>computed</code>只有当页面数据变化时才会计算，当数据没有变化时，它会读取缓存。而<code>watch</code>每次都需要执行函数，<code>methods</code>也是每次都需要执行</p><p><code>computed</code>属性的结果会被缓存，除非以来的响应式属性变化才会重新计算，主要当做属性来使用；</p><a id="more"></a><p><code>methods</code>方法表示一个具体的操作，主要来写业务逻辑；</p><p><code>watch</code>一个对象，键是需要监听的表达式，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看做是<code>computed</code>和<code>methods</code>的结合体。</p><p>如果一个数据依赖于其他数据，那么把这个数据设计为<code>computed</code>的</p><p>如果你需要在某个数据变化时做一些事情，使用<code>watch</code>来观察这个数据变化</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;computed计算属性与watch的区别&quot;&gt;&lt;a href=&quot;#computed计算属性与watch的区别&quot; class=&quot;headerlink&quot; title=&quot;computed计算属性与watch的区别&quot;&gt;&lt;/a&gt;&lt;code&gt;computed&lt;/code&gt;计算属性与&lt;code&gt;watch&lt;/code&gt;的区别&lt;/h3&gt;&lt;p&gt;&lt;code&gt;computed&lt;/code&gt;和&lt;code&gt;watch&lt;/code&gt;都是观察页面的数据变化的。 &lt;/p&gt;&lt;p&gt;&lt;code&gt;computed&lt;/code&gt;只有当页面数据变化时才会计算，当数据没有变化时，它会读取缓存。而&lt;code&gt;watch&lt;/code&gt;每次都需要执行函数，&lt;code&gt;methods&lt;/code&gt;也是每次都需要执行&lt;/p&gt;&lt;p&gt;&lt;code&gt;computed&lt;/code&gt;属性的结果会被缓存，除非以来的响应式属性变化才会重新计算，主要当做属性来使用；&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue计算属性</title>
    <link href="http://yoursite.com/2018/08/16/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/08/16/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</id>
    <published>2018-08-16T12:15:57.000Z</published>
    <updated>2018-08-16T12:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p> 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</p><p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。 </p><p>表达式里面包含了3个操作，有时候可能会更加复杂，这时我们可以使用计算属性。如下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;reversedText&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                text: &apos;123,456&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            reversedText: function () &#123;</span><br><span class="line">                //这里的this指向的是当前的vue实例</span><br><span class="line">                return this.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;);  //如果这两的text是后台接受的数据，最好加个判断数据为不为空</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 所有计算属性都以函数的形式写在<code>Vue</code>实例内的<code>computed</code>选项内，最终返回计算后的结果 </p><h3 id="计算属性用法"><a href="#计算属性用法" class="headerlink" title="计算属性用法"></a>计算属性用法</h3><p>在一个计算属性里可以完成各种复杂的逻辑，包括逻辑运算、函数调用等，只要最终返回一个结果就可以。除了上面的简单的用法，计算属性还可以依赖多个<code>vue</code>实例的数据，只要其中任意一个数据变化，计算属性就会重新执行，视图也会更新，例如下面的例子展示的是购物车内两个包裹的物品总价 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;prices&quot;&gt;</span><br><span class="line">         总价： &#123;&#123;prices&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">       // &lt;!--购物车总价--&gt;</span><br><span class="line">        var prices = new Vue(&#123;</span><br><span class="line">            el: &quot;#prices&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                package1: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为mate20pro&quot;,</span><br><span class="line">                    price: 4566,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为p30&quot;,</span><br><span class="line">                    price: 4166,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                ],</span><br><span class="line">                package2: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;苹果&quot;,</span><br><span class="line">                    price: 30,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;香蕉&quot;,</span><br><span class="line">                    price: 2,</span><br><span class="line">                    count: 20</span><br><span class="line">                &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                prices: function () &#123;</span><br><span class="line">                    var prices = 0;</span><br><span class="line">                    debugger</span><br><span class="line">                    for (var i = 0; i &lt; this.package1.length; i++) &#123;</span><br><span class="line">                        prices += this.package1[i].price * this.package1[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (var i = 0; i &lt; this.package2.length; i++) &#123;</span><br><span class="line">                        prices += this.package2[i].price * this.package2[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return prices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 当package1或package2中的商品发生变化，比如购买数量变化或者增删商品时，计算属性prices就会自动更新，视图中的总价也会自动变化<br>每个计算属性都包含一个getter和setter，上面的例子都是计算属性默认用法，只是利用了getter来读取。在你需要时，也可以提供一个setter函数，当手动修改计算属性的值就像修改一个普通数据那样，就会触发setter函数，执行一些自定义的操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--setter--&gt;</span><br><span class="line">        &lt;div id=&quot;setter&quot;&gt;</span><br><span class="line">         姓名： &#123;&#123;fullName&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> var setter = new Vue(&#123;</span><br><span class="line">            el: &quot;setter&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                firstName: &apos;Jack&apos;,</span><br><span class="line">                lastName:&apos;Green&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                fullName: &#123;</span><br><span class="line">                    //getter,用于读取</span><br><span class="line">                    get: function ()</span><br><span class="line">                    &#123;</span><br><span class="line">                        return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">                    &#125;,</span><br><span class="line">                    //setter，写入时触发</span><br><span class="line">                    set: function (newValue)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var names = newValue.split(&apos; &apos;);</span><br><span class="line">                        this.firstName = names[0];</span><br><span class="line">                        this.lastName = names[1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 当执行 setter.fullName=’Join Doe’时候，setter就会被调用，数据firstName和lastName都会相对更新，视图同样也会更新<br>    绝大多情况下，我们只会使用默认的getter方法来读取一个计算属性，在业务中很少使用到setter，所以在声明一个计算属性的时候，可以直接使用默认的写法，不必将getter和setter都声明<br>   计算属性除啦以上简单的文本插值外，还经常用于动态的设置元素的样式名称class和内联样式style，当使用组件时，计算属性也经常用来动态传递props以后，我会慢慢介绍到<br>计算属性还有两个很使用的小技巧很容易被忽略，一是计算属性可以依赖其他计算属性，二是计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他Vue实例的数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;div id=&quot;app2&quot;&gt;</span><br><span class="line">         &#123;&#123;reversedText&#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var app1 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app1&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: &quot;123,456&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var app2 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app2&quot;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                reversedText: function () &#123;</span><br><span class="line">                    //这里是依赖app1实例中的数据text</span><br><span class="line">                    return app1.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 这里我们创建了两个vue实例app1和app2，在app2的计算属性reversedText中，依赖的是app1的数据text，所以当text变化时，实例app2的计算属性也会变化，这样的用法以后用到的也会比较多，尤其是在多人协同开发时很常用，以为你写的组件所用到的数据需要依赖他人的组件提供，以后接触的多了就会慢慢的意识到这一点。 </p><h3 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a><strong>计算属性缓存</strong></h3><p> 其实细心的话就会发现，调用methods里的方法也能实现和计算属性一样的效果，甚至有的方法还能接收参数，使用起来更加的灵活，既然使用methods就可以实现，那为什么还需要计算属性呢？原因就是计算属性是基于他的依赖缓存的。一个计算属性所依赖的数据发生变化时，他才会重新取值，<br>所以依赖的text只要不改变。计算属性也就不更新 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed：&#123;</span><br><span class="line">now：function()</span><br><span class="line"> &#123;</span><br><span class="line">return Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的<code>Date.now()</code>不是响应式依赖，所以计算属性<code>now</code> 不会更新，但是<code>methods</code>则不同，只要重新渲染他就会被调用，因此函数也会被执行。<br>使用计算属性还是<code>methods</code>取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存 </p><p><code>methods</code>和计算属性<code>computed</code> 实现的最终效果其实是一样的，然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 数据  没有发生改变，多次访问 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用<code>methods</code>方法将总会再次执行函数。</p><p>计算属性的求值结果会被缓存起来，方便下次直接使用，如果计算属性方法中所依赖的任何数据都没有发生过改变，则不会重新对计算属性求值。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h3&gt;&lt;p&gt; 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： &lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&amp;#123; message.split(&amp;apos;&amp;apos;).reverse().join(&amp;apos;&amp;apos;) &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue-router</title>
    <link href="http://yoursite.com/2018/08/15/Vue-router/"/>
    <id>http://yoursite.com/2018/08/15/Vue-router/</id>
    <published>2018-08-15T12:59:32.000Z</published>
    <updated>2018-08-15T12:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol><li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p></li><li><p>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p></li><li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p></li></ol><a id="more"></a><h3 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h3><p>导入 vue-router 组件类库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span><br><span class="line">  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用 router-link 组件来导航</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>使用 router-view 组件来显示匹配到的组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>创建使用<code>Vue.extend</code>创建组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 4.1 使用 Vue.extend 来创建登录组件</span><br><span class="line">   var login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 4.2 使用 Vue.extend 来创建注册组件</span><br><span class="line">   var register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span><br><span class="line">    var router = new VueRouter(&#123;</span><br><span class="line">      routes: [</span><br><span class="line">        &#123; path: &apos;/login&apos;, component: login &#125;,</span><br><span class="line">        &#123; path: &apos;/register&apos;, component: register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>使用 router 属性来使用路由规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 6. 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      router: router // 使用 router 属性来使用路由规则</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h3><p>在规则中定义参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;/register/:id&apos;, component: register &#125;</span><br></pre></td></tr></table></figure><p>通过 <code>this.$route.params</code>来获取路由中的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var register = Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   // 父路由中的组件</span><br><span class="line">   const account = Vue.extend(&#123;</span><br><span class="line">     template: `&lt;div&gt;</span><br><span class="line">       这是account组件</span><br><span class="line">       &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | </span><br><span class="line">       &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;</span><br><span class="line">       &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">     &lt;/div&gt;`</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 login 组件</span><br><span class="line">   const login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;登录组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 register 组件</span><br><span class="line">   const register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 路由实例</span><br><span class="line">   var router = new VueRouter(&#123;</span><br><span class="line">     routes: [</span><br><span class="line">       &#123; path: &apos;/&apos;, redirect: &apos;/account/login&apos; &#125;, // 使用 redirect 实现路由重定向</span><br><span class="line">       &#123;</span><br><span class="line">         path: &apos;/account&apos;,</span><br><span class="line">         component: account,</span><br><span class="line">         children: [ // 通过 children 数组属性，来实现路由的嵌套</span><br><span class="line">           &#123; path: &apos;login&apos;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符</span><br><span class="line">           &#123; path: &apos;register&apos;, component: register &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">   var vm = new Vue(&#123;</span><br><span class="line">     el: &apos;#app&apos;,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     methods: &#123;&#125;,</span><br><span class="line">     components: &#123;</span><br><span class="line">       account</span><br><span class="line">     &#125;,</span><br><span class="line">     router: router</span><br><span class="line">   &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路由&quot;&gt;&lt;/a&gt;路由&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue子组件向父组件传值</title>
    <link href="http://yoursite.com/2018/08/14/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2018/08/14/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2018-08-14T01:04:57.000Z</published>
    <updated>2018-08-14T01:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure><p>3、子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 引用父组件 --&gt;</span><br><span class="line">    &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 组件模板定义 --&gt;</span><br><span class="line">    &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 子组件的定义方式</span><br><span class="line">    Vue.component(&apos;son&apos;, &#123;</span><br><span class="line">      template: &apos;#son&apos;, // 组件模板Id</span><br><span class="line">      methods: &#123;</span><br><span class="line">        sendMsg() &#123; // 按钮的点击事件</span><br><span class="line">          this.$emit(&apos;func&apos;, &apos;OK&apos;); // 调用父组件传递过来的方法，同时把数据传递出去</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span><br><span class="line">          alert(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;子组件向父组件传值&quot;&gt;&lt;a href=&quot;#子组件向父组件传值&quot; class=&quot;headerlink&quot; title=&quot;子组件向父组件传值&quot;&gt;&lt;/a&gt;子组件向父组件传值&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；&lt;/li&gt;
&lt;li&gt;父组件将方法的引用传递给子组件，其中，&lt;code&gt;getMsg&lt;/code&gt;是父组件中&lt;code&gt;methods&lt;/code&gt;中定义的方法名称，&lt;code&gt;func&lt;/code&gt;是子组件调用传递过来方法时候的方法名称&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue父组件向子组件传值</title>
    <link href="http://yoursite.com/2018/08/14/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2018/08/14/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</id>
    <published>2018-08-14T00:04:57.000Z</published>
    <updated>2021-06-05T18:47:37.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>1、组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;这是父组件中的消息&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        son: &#123;</span><br><span class="line">          template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;,</span><br><span class="line">          props: [&apos;finfo&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;父组件向子组件传值&quot;&gt;&lt;a href=&quot;#父组件向子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父组件向子组件传值&quot;&gt;&lt;/a&gt;父组件向子组件传值&lt;/h3&gt;&lt;p&gt;1、组件实例定义方式，注意：一定要使用&lt;code&gt;props&lt;/code&gt;属性来定义父组件传递过来的数据&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 创建 Vue 实例，得到 ViewModel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var vm = new Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      el: &amp;apos;#app&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      data: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        msg: &amp;apos;这是父组件中的消息&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      components: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        son: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          template: &amp;apos;&amp;lt;h1&amp;gt;这是子组件 --- &amp;#123;&amp;#123;finfo&amp;#125;&amp;#125;&amp;lt;/h1&amp;gt;&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          props: [&amp;apos;finfo&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue注册局部子组件</title>
    <link href="http://yoursite.com/2018/08/12/Vue%E6%B3%A8%E5%86%8C%E5%B1%80%E9%83%A8%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/08/12/Vue%E6%B3%A8%E5%86%8C%E5%B1%80%E9%83%A8%E5%AD%90%E7%BB%84%E4%BB%B6/</id>
    <published>2018-08-12T09:15:44.000Z</published>
    <updated>2018-08-12T09:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><p>1、组件实例定义方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components: &#123; </span><br><span class="line">        account: &#123; </span><br><span class="line">          template: &apos;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、引用组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">account</span>&gt;</span><span class="tag">&lt;/<span class="name">account</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h3><ol><li><p>页面结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt;</span><br><span class="line">    &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt;</span><br><span class="line">    &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><p>2.Vue实例内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&apos;myCom1&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h3&gt;奔波霸&lt;/h3&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.component(&apos;myCom2&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h3&gt;霸波奔&lt;/h3&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        flag: true</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-is属性来切换不同的子组件"><a href="#使用-is属性来切换不同的子组件" class="headerlink" title="使用:is属性来切换不同的子组件"></a>使用<code>:is</code>属性来切换不同的子组件</h3><p>1、组件实例定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录组件</span></span><br><span class="line">   <span class="keyword">const</span> login = Vue.extend(&#123;</span><br><span class="line">     template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">       &lt;h3&gt;登录组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;`</span></span><br><span class="line">   &#125;);</span><br><span class="line">   Vue.component(<span class="string">'login'</span>, login);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册组件</span></span><br><span class="line">   <span class="keyword">const</span> register = Vue.extend(&#123;</span><br><span class="line">     template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">       &lt;h3&gt;注册组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;`</span></span><br><span class="line">   &#125;);</span><br><span class="line">   Vue.component(<span class="string">'register'</span>, register);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     el: <span class="string">'#app'</span>,</span><br><span class="line">     data: &#123; <span class="attr">comName</span>: <span class="string">'login'</span> &#125;,</span><br><span class="line">     methods: &#123;&#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>2、使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='login'"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='register'"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"comName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;使用components属性定义局部子组件&quot;&gt;&lt;a href=&quot;#使用components属性定义局部子组件&quot; class=&quot;headerlink&quot; title=&quot;使用components属性定义局部子组件&quot;&gt;&lt;/a&gt;使用&lt;code&gt;components&lt;/code&gt;属性定义局部子组件&lt;/h3&gt;&lt;p&gt;1、组件实例定义方式&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 创建 Vue 实例，得到 ViewModel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var vm = new Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      el: &amp;apos;#app&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      data: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      methods: &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      components: &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        account: &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          template: &amp;apos;&amp;lt;div&amp;gt;&amp;lt;h1&amp;gt;这是Account组件&amp;#123;&amp;#123;name&amp;#125;&amp;#125;&amp;lt;/h1&amp;gt;&amp;lt;login&amp;gt;&amp;lt;/login&amp;gt;&amp;lt;/div&amp;gt;&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue组件的注册</title>
    <link href="http://yoursite.com/2018/08/12/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C/"/>
    <id>http://yoursite.com/2018/08/12/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C/</id>
    <published>2018-08-12T07:15:44.000Z</published>
    <updated>2018-08-12T07:15:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h3><p>什么是组件： 组件的出现，就是为了拆分<code>Vue</code>的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从<code>UI</code>界面的角度进行划分的；前端的组件化，方便<code>UI</code>组件的重用；</li></ul><a id="more"></a><h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><p>1、使用<code>Vue. extend</code>配合<code>Vue.component</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> login=Vue.extend(&#123;</span><br><span class="line">template:<span class="string">'&lt;h1&gt;登陆组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(<span class="string">'login'</span>,login)</span><br></pre></td></tr></table></figure><p>2、直接使用<code>Vue.component</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'register'</span>,&#123;</span><br><span class="line">template:<span class="string">'&lt;h1&gt;注册组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、将模板字符串，定义到<code>script</code>标签中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同时需要使用<code>Vue.component</code>来注册组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;,&#123;</span><br><span class="line">template:&apos;#tmp1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意： 组件中的<code>DOM</code>结构，有且只能有唯一的根元素（<code>Root Element</code>）来进行包裹！</p><h3 id="组建中展示数据和响应事件"><a href="#组建中展示数据和响应事件" class="headerlink" title="组建中展示数据和响应事件"></a>组建中展示数据和响应事件</h3><p>1、在组件中，<code>data</code>需要被定义为一个方法</p><p> 组件中的<code>data</code>写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份<code>data</code>，就会造成一个变了全都会变的结果。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'account'</span>, &#123;</span><br><span class="line">      template: <span class="string">'#tmpl'</span>,</span><br><span class="line">      data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          msg: <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(<span class="string">'点击了登录按钮'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>2、在子组件中。如果将模板字符串定义到了<code>script</code>标签中了，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;定义Vue组件&quot;&gt;&lt;a href=&quot;#定义Vue组件&quot; class=&quot;headerlink&quot; title=&quot;定义Vue组件&quot;&gt;&lt;/a&gt;定义Vue组件&lt;/h3&gt;&lt;p&gt;什么是组件： 组件的出现，就是为了拆分&lt;code&gt;Vue&lt;/code&gt;的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；&lt;br&gt;组件化和模块化的不同：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；&lt;/li&gt;
&lt;li&gt;组件化： 是从&lt;code&gt;UI&lt;/code&gt;界面的角度进行划分的；前端的组件化，方便&lt;code&gt;UI&lt;/code&gt;组件的重用；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue过渡、动画</title>
    <link href="http://yoursite.com/2018/08/05/Vue%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2018/08/05/Vue%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB/</id>
    <published>2018-08-05T02:44:11.000Z</published>
    <updated>2018-08-05T02:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p><p> Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 </p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><a id="more"></a><h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><p>HTML结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动起来"</span> @<span class="attr">click</span>=<span class="string">"myAnimate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VM实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    isshow: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myAnimate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>定义两组类样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义进入和离开时候的过渡状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter-active</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.2s</span> ease;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义进入过渡的开始状态 和 离开过渡的结束状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用第三方CSS动画库"><a href="#使用第三方CSS动画库" class="headerlink" title="使用第三方CSS动画库"></a>使用第三方CSS动画库</h3><p>1、导入动画类库：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./lib/animate.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、定义 transition 及属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag"><span class="attr">enter-active-class</span>=<span class="string">"fadeInRight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">"fadeOutRight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"animated"</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><p>1、定义 transition 组件以及三个钩子函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换动画"</span> @<span class="attr">click</span>=<span class="string">"isshow = !isshow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">before-enter</span>=<span class="string">"beforeEnter"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">after-enter</span>=<span class="string">"afterEnter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"isshow"</span> <span class="attr">class</span>=<span class="string">"show"</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、定义三个 methods 钩子方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        beforeEnter(el) &#123; <span class="comment">// 动画进入之前的回调</span></span><br><span class="line">          el.style.transform = <span class="string">'translateX(500px)'</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        enter(el, done) &#123; <span class="comment">// 动画进入完成时候的回调</span></span><br><span class="line">          el.offsetWidth;</span><br><span class="line">          el.style.transform = <span class="string">'translateX(0px)'</span>;</span><br><span class="line">          done();</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter(el) &#123; <span class="comment">// 动画进入完成之后的回调</span></span><br><span class="line">          <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>3、定义动画过渡时长和样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.4s</span> ease;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；&lt;/p&gt;&lt;p&gt; Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 &lt;/p&gt;&lt;ul&gt;
&lt;li&gt;在 CSS 过渡和动画中自动应用 class&lt;/li&gt;
&lt;li&gt;可以配合使用第三方 CSS 动画库，如 Animate.css&lt;/li&gt;
&lt;li&gt;在过渡钩子函数中使用 JavaScript 直接操作 DOM&lt;/li&gt;
&lt;li&gt;可以配合使用第三方 JavaScript 动画库，如 Velocity.js&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue实例的生命周期函数</title>
    <link href="http://yoursite.com/2018/08/02/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/02/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</id>
    <published>2018-08-02T14:55:44.000Z</published>
    <updated>2018-08-02T14:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h2><ul><li><p>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</p></li><li><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p></li><li><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p><h3 id="主要的生命周期函数分类："><a href="#主要的生命周期函数分类：" class="headerlink" title="主要的生命周期函数分类："></a>主要的生命周期函数分类：</h3></li></ul><h4 id="创建期间的生命周期函数："><a href="#创建期间的生命周期函数：" class="headerlink" title="创建期间的生命周期函数："></a>创建期间的生命周期函数：</h4><ul><li>beforeCreate：刚初始化一个Vue空的实例对象，这个对象上只有一些生命周期函数和默认的事件，此时，还没有初始化好 data 和 methods 的数据</li><li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板（如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作）</li><li>beforeMount：开始编辑模板 在内存中生成一个编译好的最终模板字符串，然后渲染为内存中的DOM，此时已经完成了模板的编译，但是还没有挂载到真正的页面中</li><li>mounted：此时，表示整个Vue实例已经初始化完毕了，已经将编译好的模板，挂载到了页面指定的容器中显示</li></ul><a id="more"></a><h4 id="运行期间的生命周期函数："><a href="#运行期间的生命周期函数：" class="headerlink" title="运行期间的生命周期函数："></a>运行期间的生命周期函数：</h4><ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul><h4 id="销毁期间的生命周期函数："><a href="#销毁期间的生命周期函数：" class="headerlink" title="销毁期间的生命周期函数："></a>销毁期间的生命周期函数：</h4><ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。实例身上所有的data和所有的methods以及过滤器、指令….都处于可用状态，还没有真正执行销毁的过程</li><li>destroyed：Vue 实例销毁后调用。已经完全被销毁，此时实例所有的数据、方法、指令过滤器都不可用了</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Vue实例的生命周期&quot;&gt;&lt;a href=&quot;#Vue实例的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Vue实例的生命周期&quot;&gt;&lt;/a&gt;Vue实例的生命周期&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/api/#选项-生命周期钩子&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;生命周期钩子&lt;/a&gt;：就是生命周期事件的别名而已；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生命周期钩子 = 生命周期函数 = 生命周期事件&lt;/p&gt;
&lt;h3 id=&quot;主要的生命周期函数分类：&quot;&gt;&lt;a href=&quot;#主要的生命周期函数分类：&quot; class=&quot;headerlink&quot; title=&quot;主要的生命周期函数分类：&quot;&gt;&lt;/a&gt;主要的生命周期函数分类：&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;创建期间的生命周期函数：&quot;&gt;&lt;a href=&quot;#创建期间的生命周期函数：&quot; class=&quot;headerlink&quot; title=&quot;创建期间的生命周期函数：&quot;&gt;&lt;/a&gt;创建期间的生命周期函数：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;beforeCreate：刚初始化一个Vue空的实例对象，这个对象上只有一些生命周期函数和默认的事件，此时，还没有初始化好 data 和 methods 的数据&lt;/li&gt;
&lt;li&gt;created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板（如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作）&lt;/li&gt;
&lt;li&gt;beforeMount：开始编辑模板 在内存中生成一个编译好的最终模板字符串，然后渲染为内存中的DOM，此时已经完成了模板的编译，但是还没有挂载到真正的页面中&lt;/li&gt;
&lt;li&gt;mounted：此时，表示整个Vue实例已经初始化完毕了，已经将编译好的模板，挂载到了页面指定的容器中显示&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue-resource插件</title>
    <link href="http://yoursite.com/2018/07/27/Vue-resource%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/07/27/Vue-resource%E6%8F%92%E4%BB%B6/</id>
    <published>2018-07-27T14:50:45.000Z</published>
    <updated>2018-07-27T14:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>下载地址：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/pagekit/vue-resource/blob/develop/docs/http.md</span><br></pre></td></tr></table></figure><p>$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。</p><a id="more"></a><p>vue-resource的特点：</p><ol><li>体积小</li></ol><p>vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。</p><ol start="2"><li>支持主流的浏览器</li></ol><p>和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。</p><ol start="3"><li>支持Promise API和URI Templates</li></ol><p>Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。<br>URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。</p><ol start="4"><li>支持拦截器</li></ol><p>拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。<br>拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。</p><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        userList:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getdata:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//请求的url</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="string">'https://www.layui.com/demo/table/user/'</span>;</span><br><span class="line">            <span class="comment">//利用vue-resource发出Ajax请求</span></span><br><span class="line">            <span class="keyword">this</span>.$http.get(url)<span class="comment">//发出请求</span></span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;<span class="comment">//获取服务器返回的数据</span></span><br><span class="line">                <span class="keyword">this</span>.userList = response.body;<span class="comment">//获取当前url响应回来的数据</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        postdata:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//请求的url</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="string">'https://www.layui.com/demo/table/user/'</span>;</span><br><span class="line">            <span class="comment">//利用vue-resource发出Ajax请求</span></span><br><span class="line">            <span class="comment">//post有三个参数:post(url,传入服务器的请求报文体数据,&#123;emulateJson:true&#125;)</span></span><br><span class="line">            <span class="keyword">this</span>.$http.post(url,&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;,&#123;<span class="attr">emulateJson</span>:<span class="literal">true</span>&#125;)<span class="comment">//发出post请求</span></span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;<span class="comment">//获取服务器返回的数据</span></span><br><span class="line">                <span class="built_in">console</span>.log(response.body);<span class="comment">//获取当前url响应回来的数据</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; &lt;strong&gt;下载地址：&lt;/strong&gt; &lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://github.com/pagekit/vue-resource/blob/develop/docs/http.md&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue自定义指令</title>
    <link href="http://yoursite.com/2018/07/27/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/27/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</id>
    <published>2018-07-27T13:45:05.000Z</published>
    <updated>2018-07-27T13:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。</p><p>自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。</p><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><p><strong>bind：</strong>只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。</p><a id="more"></a><p><strong>inserted：</strong>被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p><p><strong>update：</strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p><p><strong>componentUpdated：</strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p><p><strong>unbind：</strong>只调用一次，指令与元素解绑时调用。</p><h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><p>指令钩子函数会被传入以下参数：</p><p>el：指令所绑定的元素，可以用来直接操作 DOM 。<br>binding：一个对象，包含以下属性：<br>name：指令名，不包括 v- 前缀。<br>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1”中，表达式为 “1 + 1”。<br>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。<br>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。<br>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue1.0中提供了一个Vue.directive(自定义指令名称，回调函数)来供程序员自定义指令</span></span><br><span class="line"><span class="comment">//注意:在定义指令时不需要加v-前缀但是使用时必须加v-前缀</span></span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 聚焦元素</span></span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个v-color指令</span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素被绑定时</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>) </span>&#123;</span><br><span class="line">        el.style.color = binding.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用自定义指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus v-color=&quot;customColor&quot; placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">    el: &apos;#app-4&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">directives: &#123;</span><br><span class="line">        focus: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            inserted: function(el) &#123;</span><br><span class="line">                el.focus()</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用自定义元素 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。&lt;/p&gt;&lt;p&gt;自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。&lt;/p&gt;&lt;h4 id=&quot;钩子函数&quot;&gt;&lt;a href=&quot;#钩子函数&quot; class=&quot;headerlink&quot; title=&quot;钩子函数&quot;&gt;&lt;/a&gt;钩子函数&lt;/h4&gt;&lt;p&gt;一个指令定义对象可以提供如下几个钩子函数 (均为可选)：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;bind：&lt;/strong&gt;只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue按键修饰符</title>
    <link href="http://yoursite.com/2018/07/26/Vue%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2018/07/26/Vue%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2018-07-26T13:05:44.000Z</published>
    <updated>2018-07-26T13:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>  在监听键盘事件时，我们经常需要监听常见的键值，vue允许v-on在监听键盘事件时添加按键修饰符： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        序号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"idValue"</span>/&gt;</span></span><br><span class="line">        车名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"nameValue"</span> @<span class="attr">keyup.enter</span>=<span class="string">"add()"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">           序号：&#123;&#123;item.id &#125;&#125; , 车名：&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                idValue:<span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">                nameValue:<span class="string">''</span>,</span></span><br><span class="line">                list:[</span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'奥迪'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'宝马'</span>&#125;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                add()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.list.unshift(&#123;</span></span><br><span class="line"><span class="javascript">                        id : <span class="keyword">this</span>.idValue,</span></span><br><span class="line"><span class="javascript">                        name : <span class="keyword">this</span>.nameValue</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p> 这里在车名的input框里添加keyup事件，即键盘按下抬起时触发；后面的“enter”即为按键修饰符，定义哪个按键会触发该事件。所以当光标位于该input框时，按下Enter键抬起就会触发事件执行add方法，并添加新数据展示在页面上。 </p><p> 除了enter键以外，vue还定义了以下按键修饰符：tab、delete (捕获“删除”和“退格”键)、esc、space、up、down、left、right；这些是官网提供的修饰符，但是实际进行操作的时候发现，几乎所有的键盘按键都可以用来作为修饰符。</p><p> 除了使用以上方法，我们还可以使用keycode（键盘码）来作为修饰符使用。如：f2的键盘码为113，我们可以修改代码为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">车名：&lt;input type=&quot;text&quot; v-model=&quot;nameValue&quot; @keyup.113=&quot;add()&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这时光标在input框时，我们按下再松开f2时也可以触发事件。</p><p>注：不管是使用键盘名称还是使用键盘码都要防止快捷键的冲突，快捷键冲突的时候会不起作用。</p><p>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes.f2 = 113;</span><br></pre></td></tr></table></figure><p>使用自定义的按键修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;  在监听键盘事件时，我们经常需要监听常见的键值，vue允许v-on在监听键盘事件时添加按键修饰符： &lt;/p&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;divi&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        序号：&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;idValue&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        车名：&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-model&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;nameValue&quot;&lt;/span&gt; @&lt;span class=&quot;attr&quot;&gt;keyup.enter&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;add()&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-for&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;item in list&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           序号：&amp;#123;&amp;#123;item.id &amp;#125;&amp;#125; , 车名：&amp;#123;&amp;#123; item.name &amp;#125;&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; vm = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vue(&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;            el:&lt;span class=&quot;string&quot;&gt;&quot;#app&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            data:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                idValue:&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                nameValue:&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                list:[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                    &amp;#123;&lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;奥迪&#39;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                    &amp;#123;&lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;宝马&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            methods:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                add()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.list.unshift(&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                        id : &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.idValue,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;                        name : &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nameValue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
</feed>
