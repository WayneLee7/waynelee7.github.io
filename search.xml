<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3新特性</title>
    <url>/2018/05/30/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="css3有哪些新特性"><a href="#css3有哪些新特性" class="headerlink" title="css3有哪些新特性"></a>css3有哪些新特性</h1><ol>
<li>实现圆角<code>border-radius</code>、阴影<code>box-shadow</code>、<code>border-image</code>；</li>
<li>对文字加特效<code>text-shadow</code>、线性渐变<code>gradient</code>、旋转<code>transform</code>；</li>
<li><code>transform</code>：旋转<code>rotate（9deg）</code>、缩放<code>scale（0.85,0.9）</code>、定位<code>translate（0px，-30px）</code>、倾斜<code>skew（-9deg、0deg）</code>；</li>
<li>增加了更多的css选择器、多背景、rgba</li>
<li>在css3中引入为一个的伪类：：selection</li>
<li>媒体查询、多栏布局</li>
</ol>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>HTML相关的面试题</title>
    <url>/2018/05/30/HTML%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="html相关-面试问题"><a href="#html相关-面试问题" class="headerlink" title="html相关 面试问题"></a>html相关 面试问题</h1><h4 id="1-h5新标签有哪些？为什么要加强语义化？"><a href="#1-h5新标签有哪些？为什么要加强语义化？" class="headerlink" title="1. h5新标签有哪些？为什么要加强语义化？"></a>1. h5新标签有哪些？为什么要加强语义化？</h4><p>新标签：</p><p><strong>文档类型设定</strong>：<code>!doctype html</code>；</p><p><strong>字符设定</strong>：<code>meta charset=&quot;utf-8&quot;</code>；</p><p><strong>常用新标签</strong>：</p><p> <code>header</code>，一般作为网页的<strong>头部</strong>使用，可以多个；</p><p> <code>footer</code>，底部，<strong>不一定是文档最底部</strong>，可以多个；</p><a id="more"></a>





<p> <code>aside</code>，<strong>侧边</strong>栏；</p>
<p> <code>nav</code>，<strong>导航</strong>栏；</p>
<p> <code>article</code>，独立内容区域，与session类似，<strong>用于文章blog、帖子、短文或者回复、评论</strong>等；</p>
<p> <code>section</code>，代表某一个区域/分区/页面/文档的<strong>一部分区域</strong>，有独立的内容，但结构相近，就可以用section，范围比div大，语义比div更强，可以包含header、<code>h1-h6</code>……凸显语义的标签；</p>
<p> <code>datalist</code>，<strong>标签定义选项列表</strong>，请与 input 元素配合使用该元素；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;输入&quot; list=&quot;TFboys&quot;/&gt; &lt;!--  input里面用list --&gt;</span><br><span class="line">&lt;datalist id=&quot;TFboys&quot;&gt;   &lt;!-- datalist里面用id --&gt;  </span><br><span class="line">        &lt;option&gt;易烊千玺&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;王俊凯&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;王源&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<p> <code>fieldset</code>，可<strong>将表单内的相关元素分组</strong>，打包legend（为<code>fieldset</code>元素定义标题）使用； </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;fieldset&gt;</span><br><span class="line">	&lt;legend&gt;用户登录&lt;/legend&gt;</span><br><span class="line">    	用户名: &lt;input type=&quot;text&quot;&gt;&lt;br /&gt;</span><br><span class="line">		密　码: &lt;input type=&quot;password&quot;&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br></pre></td></tr></table></figure>
<p> <code>address</code>，<strong>标签定义文档或文章的作者/拥有者的联系信息</strong>，字体样式默认倾斜； <code>time</code>，时间标签，主要用于搜索引擎和其它一些内容引擎特殊的解析和展示； <code>hgroup</code>，专门用来包含标题<strong>h标签的分组</strong>；</p>
<p> <code>detail</code>，<em>细节、详情</em> ，open属性：默认展开，summary相当于详情的标题；</p>
<p> <strong>新增了许多input type属性</strong>：<code>email</code>、<code>tel</code>、<code>url</code>、<code>number</code>、<code>search搜索框，加强语义</code>、<code>range自由拖动滑块</code>、<code>time</code>、<code>date日期</code>、<code>datetime时间</code>、<code>month</code>、<code>week</code></p>
<p> <strong>新增了许多input的属性</strong>：<code>placeholder占位符，默认文字</code>、<code>autofocus页面加载时自动获得焦点</code>、<code>multiple多文件上传</code>、<code>autocomplete</code>、<code>required必填项</code>、<code>accesskey规定激活元素的快捷键</code></p>
<p> <strong>多媒体标签</strong>：<code>embed定义嵌入的内容</code>、<code>audio播放音频</code>、<code>video播放视频</code>；</p>
<p> <code>src导入</code>，<code>autoplay自动播放</code>、<code>controls是否默认显示播放件</code>、<code>loop循环播放</code></p>
<p> ……</p>
<p> 原因：1.默认样式不一样 ；2.有SEO优化作用；</p>
<h4 id="2-行内元素、块元素有哪些？它们有什么不同？"><a href="#2-行内元素、块元素有哪些？它们有什么不同？" class="headerlink" title="2.行内元素、块元素有哪些？它们有什么不同？"></a>2.行内元素、块元素有哪些？它们有什么不同？</h4><p>行内元素：b、span、a、u、em、i、img、input、select、label、textarea、button</p>
<p>块级元素：div、h、ol、ul、dl、li、table、td、th、tr、dd、dt、p、caption</p>
<p>空元素：area、meta、link</p>
<ul>
<li><p>行内元素的特点：</p>
<p>1、行内元素<strong>只能容纳文本或者其他行内元素</strong>。</p>
<p>2、<strong>宽度只与内容有关</strong>。</p>
<p>3、和其他元素都<strong>在一行上</strong>。</p>
<p>4、高，行高及外边距和内边距<strong>左右可改变</strong>。</p>
</li>
<li><p>块级元素的特点：</p>
<p>1、高度，行高以及外边距和内边距<strong>都可控制</strong>。</p>
<p>2、总是在新行上开始，<strong>占据一整行</strong>。</p>
<p>3、它可以<strong>容纳内联元素和其他块元素</strong>。</p>
<p>4、<strong>宽度</strong>始终是与浏览器宽度一样，<strong>与内容无关</strong>。</p>
</li>
<li><p>区别：</p>
<p>1、<strong>行内元素</strong>会在<strong>一条直线上分列</strong>，都是统一行的，程度偏向分列。</p>
<p> <strong>块级元素各盘踞一行</strong>，垂直偏向分列；块级元素重新行开端停止接着一个断行。</p>
<p>2、<strong>行内元素</strong>不可以包括块级元素，只能包容文本或许其余行内元素。</p>
<p> <strong>块级元素</strong>能够包括行内元素和块级元素，还能够包容内联元素和其余元素；。</p>
<p>3、行内元素与块级元素属性的分歧，主要在盒模子属性上。</p>
<p><strong>行内元素</strong>设置width无效，height无效（<strong>能够设置line-height</strong>），margin、padding设置上下有效。</p>
</li>
<li><p>行内元素内嵌块级元素。高度被子元素撑大，而<strong>宽度和父级一致</strong>（父级是body就是body的宽度）。</p>
</li>
<li><p><strong>行内块元素</strong>内嵌块级元素。宽高都会<strong>被子元素撑大</strong>的。</p>
</li>
</ul>
<h4 id="3-html中首行-lt-doctype-gt-的作用？"><a href="#3-html中首行-lt-doctype-gt-的作用？" class="headerlink" title="3.html中首行&lt;!doctype&gt;的作用？"></a>3.html中首行&lt;!doctype&gt;的作用？</h4><p> <strong>文档类型声明</strong>，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档；声明必须是HTML文档的第一行，位于html标签之前；</p>
<h4 id="4-rem相对于根节点。em相对于父元素"><a href="#4-rem相对于根节点。em相对于父元素" class="headerlink" title="4.rem相对于根节点。em相对于父元素"></a>4.rem相对于根节点。em相对于父元素</h4><h4 id="5-一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行"><a href="#5-一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行" class="headerlink" title="5.一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行"></a>5.一般html网页元素加载完成后，会触发哪个事件？onready比onload先执行</h4><h5 id="Dom文档加载的步骤："><a href="#Dom文档加载的步骤：" class="headerlink" title="Dom文档加载的步骤："></a>Dom文档加载的步骤：</h5><ol>
<li>解析html结构；</li>
<li><strong>加载外部</strong>脚本和样式表文件；</li>
<li>解析并执行脚本；</li>
<li>dom树构建完成（DOMContentLoaded）；</li>
<li>加载图片等外部文件；</li>
<li>页面加载完毕。</li>
</ol>
<p>DOM ready：（也叫DOMContentLoaded ），在第4步完成后触发； 图片onload：是在第5步完成后触发； 页面onload：是第6步完成后触发。</p>
<p>由此可见三者执行顺序为：<strong>domready→图片load→页面load。</strong></p>
<p>执行时间上，<strong>onready比onload先执行</strong>：</p>
<p> <strong>window.onload</strong>必须等到页面内包括图片的<strong>所有元素加载完毕后才能执行</strong>。</p>
<p> <strong>$(document).ready()</strong>是<strong>DOM结构绘制完毕后就执行</strong>，不必等到加载完毕。</p>
<p><strong>onload只执行最后一个</strong>而<strong>onready可以执行多个</strong>：</p>
<p>编写个数不同 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行最后一个。 <strong>$(document).ready()可以同时编写多个，并且都可以按顺序得到执行</strong>。</p>
<p>注：$(document).ready(function(){})可以简写成$(function(){});</p>
<h4 id="6-html是怎么渲染的"><a href="#6-html是怎么渲染的" class="headerlink" title="6.html是怎么渲染的"></a>6.html是怎么渲染的</h4><p>1.解析html文件，创建DOM树 自上而下解析，遇到任何样式（link、style）和脚本（script）都会阻塞 　　1）css加载不会阻塞html文件的解析，但会阻塞dom的渲染 　　2）css加载会阻塞后面js语句的执行 　　3）js会阻塞html的解析和渲染 　　4）没有defer和async标签的script会立即加载并执行 　　5）有async标签的js，js的加载执行和html的解析和渲染并行 　　6）有defer标签的js，js的加载和html的解析和渲染并行，但会在html解析完成后执行,在触 发DOMContentLoaded事件前执行 　　7）DOMContentLoaded和onload的区别：DOMContentLoaded在html解析完毕后执行，loload在页面完全加载完成后执行（包括样式和图片） 2.解析css，生成CSSOM，css对象模型 3.dom和css合并，构建渲染树（Render Tree） 4.布局（Layout）和绘制（Paint），重绘（repaint）和重排（reflow/回流） 1）重绘：根据元素的新属性重新绘制，使元素呈现新的外观 　　2）重排：当渲染树中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建 　　3）重排必定会引发重绘，但重绘不一定会引发重排</p>
<h4 id="7-滚动条"><a href="#7-滚动条" class="headerlink" title="7.滚动条"></a>7.滚动条</h4><p>只要网页内容大于视窗，滚动条就会出现。</p>
<p>目标：没有滚动条影响美观，但仍旧可以滚动</p>
<p><strong>方法1</strong>：在webkit内核的浏览器里可以定义滚动条样式，在CSS初始处定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--Chrome--</span><br><span class="line">body::-webkit-scrollbar&#123;</span><br><span class="line">	display:none;</span><br><span class="line">&#125;</span><br><span class="line">--IE/Edge--</span><br><span class="line">body&#123;</span><br><span class="line">    -ms-overflow-style: none;</span><br><span class="line">&#125;</span><br><span class="line">--Firefox--</span><br><span class="line">html &#123;</span><br><span class="line">    overflow: -moz-hidden-unscrollable; /*注意！若只打 hidden，chrome 的其它 hidden 会出问题*/</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">	height: 100%;</span><br><span class="line">	width: calc(100vw + 18px); /*浏览器滚动条的长度大约是 18px*/</span><br><span class="line">	overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2：在div外面再套一个div，内层是有滚动条的，但是我们看不到了</p>
<p>外面的div设置overflow:hidden；</p>
<p>里面的div设置 overflow-y: scroll;overflow-x: hidden;</p>
<p>再设置外层div的width小于内层div的width。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner&quot;&gt;     </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outer&#123;</span><br><span class="line">	overflow:hidden;</span><br><span class="line">    width:200px;</span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    overflow-y:scroll;</span><br><span class="line">    overflow-x:hidden;</span><br><span class="line">    width:220px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>CSS优先级的计算方法</title>
    <url>/2018/05/29/CSS%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="css优先级的计算方法"><a href="#css优先级的计算方法" class="headerlink" title="css优先级的计算方法"></a>css优先级的计算方法</h1><h2 id="1-CSS优先级比较"><a href="#1-CSS优先级比较" class="headerlink" title="1.CSS优先级比较"></a>1.CSS优先级比较</h2><p>！important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 默认</p><h2 id="2-CSS权重计算"><a href="#2-CSS权重计算" class="headerlink" title="2.CSS权重计算"></a>2.CSS权重计算</h2><p>我们把特殊性分为4个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。</p><a id="more"></a>

<p>4个等级的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一等：代表内联样式，如: style=””，权值为1000。</span><br><span class="line">第二等：代表ID选择器，如：#content，权值为0100。</span><br><span class="line">第三等：代表类，伪类和属性选择器，如.content，权值为0010。</span><br><span class="line">第四等：代表标签选择器和伪元素选择器，如div p，权值为0001。</span><br><span class="line">第五等：通用选择器（*），子选择器（&gt;），相邻同胞选择器（+），权值为0000</span><br></pre></td></tr></table></figure>
<p>当选择不同的选择器，选中同一个元素时并且设置相同的样式时，这样样式之间就会产生冲突，最终到底采用哪个选择器定义的样式，由选择器的优先级（权重）来决定，优先级高的优先显示。</p>
<p>继承的样式没有优先级<br>当选择器包含多种选择器时，需要将多种选择器的优先级相加然后进行比较。但是注意，选择器的优先级计算不会超过他的最大数量级，如果选择器的优先级一样，则使用靠后的样式。<br>并集选择器的优先级时单独计算。<br>可以在样式的最后添加一个!important，则此时该样式会获得一个最高的一个优先级，将会超过所有的样式甚至超过内联样式，所以在开发中尽量避免使用。</p>
<p>伪类的顺序</p>
<p>涉及到a的伪类一共四个：<br>:link<br>:visited<br>:hover<br>:active<br>这四个选择器的优先级是一样的。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>HTML5新特性复习整理</title>
    <url>/2018/05/29/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p> h5是html的最新版本，是14年由w3c完成标准制定。增强了浏览器的原生功能，减少浏览器插件（eg：flash）的应用，提高用户体验满意度，让开发更加方便。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">开头的<span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"> 字符编码变得简洁，</span><br></pre></td></tr></table></figure><a id="more"></a>

<ol>
<li><p>不区分大小写，</p>
</li>
<li><p>添加了布尔值，类似checked，selected</p>
</li>
<li><p>引号可以省略，但是编码规范来说，不建议</p>
</li>
<li><p>有可以省略结束符的标签，和完全省略的标签应用。</p>
<p>标签增删</p>
<p>(1)结构标签（8个语义化元素） header, footer, section, article,aside ,nav, main,figure （全都是块元素）</p>
<p>其他语义化标签 figcaption, hgroup, dialog,details,summary</p>
<p>(2)其他功能标签，mark ，progress ，command，ruby，（rt，rp），wbr，time</p>
<p>(3)新的表单控件（input的type输入性）：email tel url number search range color</p>
<p>Date Pickers：日期选择器；（time datetime （UTC时间）datetime-local（本地时间） date month week ）</p>
<p><img src="https://img-blog.csdnimg.cn/20200313155857293.png" alt="在这里插入图片描述"> </p>
<p>（4）input新增属性值：placeholder autofocus multiple autocomplete required list height和width min和max等</p>
<p><img src="https://img-blog.csdnimg.cn/20200313161025405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
</li>
</ol>
<p>（5）新的表单元素 detailest，keygen，output</p>
<p>（6）移除过时标签 big font frame frameset</p>
<ul>
<li><p>canvas绘图 支持内联SVG 支持MathML</p>
</li>
<li><p>多媒体元素 audio video source track embed</p>
</li>
<li><p>本地离线储存 把需要离线存储在本地的文件列在一个manifest文件中</p>
</li>
<li><p>web存储 localStorage，SessionStorage**</p>
</li>
<li><p>地理定位</p>
<h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1.语义化标签"></a>1.语义化标签</h3><p>header（双标签）页眉，用于页面头部信息介绍或者板块头部。 |</p>
<p>footer（双标签）：页脚，用于页面底部或者板块底部。</p>
<p>section（双标签）：板块，用于划分页面上的不同区域，或者划分文章里不同节，属于article的部分。</p>
<p>artilce（双标签）：用来在页面中表示一套结构完整并且独立的部分，可以呈现论坛的一个帖子，杂志或报纸中的一篇文章，用户提交的评论内容，可互动的页面模块挂件等。（可以用header/footer/section等做为头部，脚步，部分）</p>
<p>aside（双标签）：用来定义其所处内容之外的内容 侧边，aside的内容应该与article相关。</p>
<p>nav（双标签）：导航，包含链接的一个列表。</p>
<p>figure（双标签） ：和文档有关的图例。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;figcaption&gt; 标签定义 figure 元素的标题（caption）。</span><br><span class="line">      &lt;figure&gt;</span><br><span class="line">       &lt;figcaption&gt;黄浦江上的的卢浦大桥&lt;/figcaption&gt;</span><br><span class="line">      &lt;img src=&quot;shanghai_lupu_bridge.jpg&quot; width=&quot;350&quot; height=&quot;234&quot; /&gt;</span><br><span class="line">     &lt; /figure&gt;</span><br><span class="line">     &quot;figcaption&quot; 元素应该被置于 &quot;figure&quot; 元素的第一个或最后一个子元素的位置。</span><br></pre></td></tr></table></figure>
<p>main（双标签）：规定文章的主要内容。<strong>注意！</strong>在一个文档中不应该出现一个以上的main元素，且main元素不能是一下元素的后代：header，footer,artilce,aside,nav.</p>
<p>hgroup（双标签）：用于对一个页面中一个区块或整个页面的标题进行组合。定义有关文档中的 section 的信息。</p>
<h3 id="2-其他功能标签"><a href="#2-其他功能标签" class="headerlink" title="2.其他功能标签"></a>2.其他功能标签</h3><p>mark ：用来展示文字高亮</p>
<p>progress：用来展示任何类型的任务的进度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;progress max=&quot;最大进度条的值&quot; value=&quot;当前进度条的值&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>command：可以定义命令按钮，比如单选按钮、复选框或按钮。</p>
<p>ruby</p>
<p>ruby ：对某一个字进行注释；</p>
<p>rt: 定义 ruby 注释的解释。(和ruby一起使用)</p>
<p>rp：rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。（和rt ruby一起使用）</p>
<p>ruby实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ruby&gt;</span><br><span class="line">漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;</span><br><span class="line">&lt;/ruby&gt;</span><br></pre></td></tr></table></figure>
<p> <strong>wbr</strong> ：软换行 （wbr元素指浏览器窗口或父级元素宽度够高时，不进行换行，宽度不够时，主动再此换行）</p>
<p><strong>time</strong>：数据标签，给搜索引擎使用；（目前所有主流浏览器不支持标签） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发布日期&lt;time datetime=&quot;2014-12-25T09:00&quot;&gt;9：00&lt;/time&gt;</span><br><span class="line">更新日期&lt;time datetime=&quot;2015- 01-23T04:00&quot; pubdate&gt;4:00&lt;/time&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-表单控件"><a href="#3-表单控件" class="headerlink" title="3.表单控件"></a>3.表单控件</h3><p> <img src="https://img-blog.csdnimg.cn/20200311211457721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/20200311211745639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="4-input-属性值"><a href="#4-input-属性值" class="headerlink" title="4.input 属性值"></a>4.input 属性值</h3><p> <img src="https://img-blog.csdnimg.cn/20200311211932255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<p> 效果图 </p>
<p> <img src="https://img-blog.csdnimg.cn/20200311212142481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE0MTg2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="5-新的表单元素"><a href="#5-新的表单元素" class="headerlink" title="5.新的表单元素"></a>5.新的表单元素</h3><p> <strong>datalist</strong> ：下拉菜单 定义选项列表，需要和input搭配使用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;</span><br><span class="line">        &lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;BMW&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;Ford&quot;&gt;</span><br><span class="line">       &lt;option value=&quot;Volvo&quot;&gt;</span><br><span class="line">      &lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<p> keygen：表示生成秘钥 （当提交表单时，私钥存储在本地，公钥发送到服务器。）（单标签） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;</span><br><span class="line">      用户名：&lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt;</span><br><span class="line">       &lt;keygen name=&quot;security&quot; /&gt;</span><br><span class="line">       &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/20200313180543842.png" alt="效果图"> </p>
<ul>
<li><p><strong>output</strong> ：定义不同类型的输出，比如脚本的输出。</p>
<h3 id="6-canvas元素：定义图形，比如图表和其他图像。"><a href="#6-canvas元素：定义图形，比如图表和其他图像。" class="headerlink" title="6.canvas元素：定义图形，比如图表和其他图像。"></a>6.canvas元素：定义图形，比如图表和其他图像。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形。</span><br><span class="line">    利用Canvas API进行绘图，首先要获取canvas元素的上下文，然后用该上下文中封装的各种绘图功能进行绘图。</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot;&gt;替代内容&lt;/canvas&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">  </span><br><span class="line">   var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">  </span><br><span class="line">   var context =canvas.getContext(&quot;2d&quot;); // 获取上下文</span><br><span class="line">  </span><br><span class="line">   //设置纯色</span><br><span class="line">  </span><br><span class="line">  context.fillStyle = &quot;red&quot;;</span><br><span class="line">  </span><br><span class="line">  context.strokeStyle = &quot;blue&quot;;</span><br><span class="line">  </span><br><span class="line"> // 实践表明在不设置fillStyle下的默认fillStyle为black</span><br><span class="line">  </span><br><span class="line">  context.fillRect(0, 0, 100, 100);</span><br><span class="line">  </span><br><span class="line">// 实践表明在不设置strokeStyle下的默认strokeStyle为black</span><br><span class="line">  </span><br><span class="line"> context.strokeRect(120, 0, 100, 100);</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-多媒体元素"><a href="#7-多媒体元素" class="headerlink" title="7.多媒体元素"></a>7.多媒体元素</h3></li>
</ul>
<p>audio： 定义声音或音乐内容 （支持ogg MP3 wav三种声音文件）</p>
<p>video ： 定义视频或影片内容 （支持ogg MP4 webM 三种视频格式）</p>
<p>Audio/Video 方法</p>
<p>source： 定义 audio和video和来源</p>
<p>track：为诸如 video 元素之类的媒介规定外部文本轨道。</p>
<p>用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。（目前所有主流浏览器都不支持 track标签）</p>
<p>embed 定义嵌入的内容，比如插件。（可以插入各种多媒体）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;embed src=&quot;/i/helloworld.swf&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-离线存储"><a href="#8-离线存储" class="headerlink" title="8.离线存储"></a>8.离线存储</h3><p> <a href="https://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="noopener">通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本</a> </p>
<h3 id="9-web存储："><a href="#9-web存储：" class="headerlink" title="9.web存储："></a>9.web存储：</h3><p>WebStorage API 可以在客户端本地存储数据，类似html4中的cookie，实现功能比cookie强</p>
<p>sessionStorage：将数据存储在session中，浏览器关闭时，数据就会消失。</p>
<p>localStorage：将数据储存在客户端本地，除非手动删除，否则一直保存。</p>
<h3 id="10-地理定位"><a href="#10-地理定位" class="headerlink" title="10.地理定位"></a>10.地理定位</h3><p><a href="https://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="noopener">HTML5 Geolocation API 用于获得用户的地理位置</a> </p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-resource插件</title>
    <url>/2018/07/27/Vue-resource%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p> <strong>下载地址：</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/pagekit/vue-resource/blob/develop/docs/http.md</span><br></pre></td></tr></table></figure><p>$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。</p><a id="more"></a>


<p>vue-resource的特点：</p>
<ol>
<li>体积小</li>
</ol>
<p>vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。</p>
<ol start="2">
<li>支持主流的浏览器</li>
</ol>
<p>和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。</p>
<ol start="3">
<li>支持Promise API和URI Templates</li>
</ol>
<p>Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。<br>URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。</p>
<ol start="4">
<li>支持拦截器</li>
</ol>
<p>拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。<br>拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。</p>
<h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        userList:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getdata:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//请求的url</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="string">'https://www.layui.com/demo/table/user/'</span>;</span><br><span class="line">            <span class="comment">//利用vue-resource发出Ajax请求</span></span><br><span class="line">            <span class="keyword">this</span>.$http.get(url)<span class="comment">//发出请求</span></span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;<span class="comment">//获取服务器返回的数据</span></span><br><span class="line">                <span class="keyword">this</span>.userList = response.body;<span class="comment">//获取当前url响应回来的数据</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        postdata:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//请求的url</span></span><br><span class="line">            <span class="keyword">var</span> url = <span class="string">'https://www.layui.com/demo/table/user/'</span>;</span><br><span class="line">            <span class="comment">//利用vue-resource发出Ajax请求</span></span><br><span class="line">            <span class="comment">//post有三个参数:post(url,传入服务器的请求报文体数据,&#123;emulateJson:true&#125;)</span></span><br><span class="line">            <span class="keyword">this</span>.$http.post(url,&#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;,&#123;<span class="attr">emulateJson</span>:<span class="literal">true</span>&#125;)<span class="comment">//发出post请求</span></span><br><span class="line">                .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;<span class="comment">//获取服务器返回的数据</span></span><br><span class="line">                <span class="built_in">console</span>.log(response.body);<span class="comment">//获取当前url响应回来的数据</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-Devtools调试工具</title>
    <url>/2018/07/24/Vue-Devtools%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="Vue在chrome浏览器的调试工具Vue-Devtools"><a href="#Vue在chrome浏览器的调试工具Vue-Devtools" class="headerlink" title="Vue在chrome浏览器的调试工具Vue-Devtools"></a>Vue在chrome浏览器的调试工具Vue-Devtools</h3><p> vue-devtools是一款基于chrome游览器的插件，用于调试vue应用，这可以极大地提高我们的调试效率。接下来我们就介绍一下vue-devtools的安装。 </p><p> <strong>安装地址：</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/vuejs/vue-devtools</span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd</span><br></pre></td></tr></table></figure>
<p>vue项目, 打开f12, 选择vue就可以使用了</p>
<p>vue是数据驱动的, 这样就能看到对应数据了, 方便我们进行调试</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-router</title>
    <url>/2018/08/15/Vue-router/</url>
    <content><![CDATA[<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li><p>对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</p>
</li>
<li><p>对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；</p>
</li>
<li><p>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；</p>
</li>
</ol><a id="more"></a>
<h3 id="在-vue-中使用-vue-router"><a href="#在-vue-中使用-vue-router" class="headerlink" title="在 vue 中使用 vue-router"></a>在 vue 中使用 vue-router</h3><p>导入 vue-router 组件类库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 导入 vue-router 组件类库 --&gt;</span><br><span class="line">  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用 router-link 组件来导航</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>使用 router-view 组件来显示匹配到的组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>创建使用<code>Vue.extend</code>创建组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 4.1 使用 Vue.extend 来创建登录组件</span><br><span class="line">   var login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 4.2 使用 Vue.extend 来创建注册组件</span><br><span class="line">   var register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则</span><br><span class="line">    var router = new VueRouter(&#123;</span><br><span class="line">      routes: [</span><br><span class="line">        &#123; path: &apos;/login&apos;, component: login &#125;,</span><br><span class="line">        &#123; path: &apos;/register&apos;, component: register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>使用 router 属性来使用路由规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 6. 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      router: router // 使用 router 属性来使用路由规则</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h3><p>在规则中定义参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; path: &apos;/register/:id&apos;, component: register &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>this.$route.params</code>来获取路由中的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var register = Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   // 父路由中的组件</span><br><span class="line">   const account = Vue.extend(&#123;</span><br><span class="line">     template: `&lt;div&gt;</span><br><span class="line">       这是account组件</span><br><span class="line">       &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | </span><br><span class="line">       &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;</span><br><span class="line">       &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">     &lt;/div&gt;`</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 login 组件</span><br><span class="line">   const login = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;登录组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 子路由中的 register 组件</span><br><span class="line">   const register = Vue.extend(&#123;</span><br><span class="line">     template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 路由实例</span><br><span class="line">   var router = new VueRouter(&#123;</span><br><span class="line">     routes: [</span><br><span class="line">       &#123; path: &apos;/&apos;, redirect: &apos;/account/login&apos; &#125;, // 使用 redirect 实现路由重定向</span><br><span class="line">       &#123;</span><br><span class="line">         path: &apos;/account&apos;,</span><br><span class="line">         component: account,</span><br><span class="line">         children: [ // 通过 children 数组属性，来实现路由的嵌套</span><br><span class="line">           &#123; path: &apos;login&apos;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符</span><br><span class="line">           &#123; path: &apos;register&apos;, component: register &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">   var vm = new Vue(&#123;</span><br><span class="line">     el: &apos;#app&apos;,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     methods: &#123;&#125;,</span><br><span class="line">     components: &#123;</span><br><span class="line">       account</span><br><span class="line">     &#125;,</span><br><span class="line">     router: router</span><br><span class="line">   &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue-router导航守卫</title>
    <url>/2018/08/29/Vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h1 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h1><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><p> 其实，导航守卫就是路由跳转过程中的一些钩子函数，再直白点路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。 </p><a id="more"></a>

<p> <strong>导航守卫分为</strong>：全局的、单个路由独享的、组件内的三种。分别来看一下： </p>
<p><strong>【全局的】</strong>：是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数，如下的写法。钩子函数按执行顺序包括<code>beforeEach</code>、<code>beforeResolve</code>（2.5+）、<code>afterEach</code>三个（以下的钩子函数都是按执行顺序讲解的）： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> <strong>全局守卫</strong></p>
<p>[<code>beforeEach</code>]：在路由跳转前触发，参数包括<code>to</code>,<code>from</code>,<code>next</code>（参数会单独介绍）三个，这个钩子作用主要是用于登录验证，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚。 </p>
<p> [<code>beforeResolve</code>]（2.5+）：这个钩子和<code>beforeEach</code>类似，也是路由跳转前触发，参数也是<code>to</code>,<code>from</code>,<code>next</code>三个，和<code>beforeEach</code>区别官方解释为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</span><br></pre></td></tr></table></figure>
<p> 即在 <code>beforeEach</code> 和 组件内<code>beforeRouteEnter</code> 之后，<code>afterEach</code>之前调用。 </p>
<p> [<code>afterEach</code>]：和<code>beforeEach</code>相反，他是在路由跳转完成后触发，参数包括<code>to</code>,<code>from</code>没有了<code>next</code>（参数会单独介绍）,他发生在<code>beforeEach</code>和<code>beforeResolve</code>之后，<code>beforeRouteEnter</code>（组件内守卫，后讲）之前。 </p>
<p><strong>路由守卫</strong></p>
<p><code>beforeEnter</code></p>
<p><strong>组件守卫</strong></p>
<p><code>beforeRouteEnter</code></p>
<p>  // 在渲染该组件的对应路由被 confirm 前调用</p>
<p>  // 不！能！获取组件实例 <code>this</code></p>
<p>  // 因为当守卫执行前，组件实例还没被创建</p>
<p>  虽然无法直接获取组件实力</p>
<p>  但是我们可以通过next参数的回调函数获取到当前实例进行操作</p>
<p>  beforeRouteEnter: (to, from, next) =&gt; {</p>
<pre><code>next((vm) =&gt; {

  //vm就是当前组件实例

});
</code></pre><p>  }</p>
<p><code>beforeRouteUpdate</code></p>
<p>  // 在当前路由改变，但是该组件被复用时调用</p>
<p>  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</p>
<p>  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</p>
<p>  // 可以访问组件实例 <code>this</code></p>
<p><code>beforeRouteLeave</code></p>
<p>  // 导航离开该组件的对应路由时调用</p>
<p>  // 可以访问组件实例 <code>this</code></p>
<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Froute-object.html" target="_blank" rel="noopener">路由对象</a></li>
<li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li>
<li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul>
<li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> （确认的）。</li>
<li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next({ path: &#39;/&#39; })</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-link.html" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。</li>
<li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://link.jianshu.com?t=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fapi%2Frouter-instance.html%23%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>router.onError()</code></a> 注册过的回调。</li>
</ul>
</li>
</ul>
<p><strong>确保要调用 <code>next</code> 方法，否则钩子就不会被 resolved。</strong></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue中computed与watch的区别</title>
    <url>/2018/08/16/Vue%E4%B8%ADcomputed%E4%B8%8Ewatch%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="computed计算属性与watch的区别"><a href="#computed计算属性与watch的区别" class="headerlink" title="computed计算属性与watch的区别"></a><code>computed</code>计算属性与<code>watch</code>的区别</h3><p><code>computed</code>和<code>watch</code>都是观察页面的数据变化的。 </p><p><code>computed</code>只有当页面数据变化时才会计算，当数据没有变化时，它会读取缓存。而<code>watch</code>每次都需要执行函数，<code>methods</code>也是每次都需要执行</p><p><code>computed</code>属性的结果会被缓存，除非以来的响应式属性变化才会重新计算，主要当做属性来使用；</p><a id="more"></a>


<p><code>methods</code>方法表示一个具体的操作，主要来写业务逻辑；</p>
<p><code>watch</code>一个对象，键是需要监听的表达式，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看做是<code>computed</code>和<code>methods</code>的结合体。</p>
<p>如果一个数据依赖于其他数据，那么把这个数据设计为<code>computed</code>的</p>
<p>如果你需要在某个数据变化时做一些事情，使用<code>watch</code>来观察这个数据变化</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/2018/09/05/Vuex/</url>
    <content><![CDATA[<h1 id="vuex的基本介绍"><a href="#vuex的基本介绍" class="headerlink" title="vuex的基本介绍"></a><code>vuex</code>的基本介绍</h1><p><code>Vuex</code>是一个专门为<code>Vue.js</code>应用程序开发的状态管理模式。它采用集中式的存储管理应用所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变。 </p><p><code>vuex</code>是<code>vue</code>的状态管理工具，状态即数据， 状态管理就是管理<code>vue</code>中的数据。 </p><h4 id="vuex的优点"><a href="#vuex的优点" class="headerlink" title="vuex的优点"></a><code>vuex</code>的优点</h4><ul>
<li>可以用来解决组件通讯的问题</li>
<li><code>vuex</code>可以用来集中的管理<code>vue</code>项目中用到的所有数据（这并不意味着要将所有的数据都交给<code>vuex</code>进行管理）</li>
</ul><a id="more"></a>


<h4 id="为什么要使用vuex"><a href="#为什么要使用vuex" class="headerlink" title="为什么要使用vuex"></a>为什么要使用<code>vuex</code></h4><ul>
<li>在大型的项目中，组件通讯会变得很混乱，使用<code>vuex</code>可以统一的管理组件之间的通讯。并且可以通过开发者工具，追踪到变化。</li>
<li>当你要开发一个大型的<code>SPA</code>应用的时候，会出现：多个视图公用一个状态、不同视图的行为要改变同一个状态的情况，遇到这种情况的时候就需要考虑使用<code>Vuex</code>了，它会把组件的共享状态抽取出来，当做一个全局单例模式进行管理，这样不管你何时何地改变状态，都会通知到使用该状态的组件做出相应的修改；</li>
</ul>
<p><code>vuex</code>其实就是用一个全局的变量保存了<code>Vue</code>项目中的所有的公共数据，类似与在前端这块放了一个数据库，大家都可以在这里存数据，删数据，改数据，读数据，是不是有点熟悉：增，删，改，查；不过这个全局的变量给他定义了一个固定的名字就叫：<code>store</code>（仓库），是不是很形象，而这个仓库里面装数据的袋子就是<code>state</code>，加工数据的机器就叫做：<code>mutations</code>，操作机器的工人就叫做：<code>actions</code>，把数据装起来取走的卡车就叫做：<code>getters</code>;<br> 所以一个简单的<code>vuex</code>就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new vuex.store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Vuex-特点"><a href="#Vuex-特点" class="headerlink" title="Vuex 特点"></a><code>Vuex</code> 特点</h3><ul>
<li><code>Vuex</code>的状态存储是响应式的。当<code>Vue</code>组件从 <code>store</code> 中读取状态的时候，若 <code>store</code> 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 <code>store</code> 中的状态。改变 <code>store</code> 中的状态的唯一途径就是显式地提交(<code>commit</code>) <code>mutations</code>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ul>
<h3 id="Vuex实例"><a href="#Vuex实例" class="headerlink" title="Vuex实例"></a><code>Vuex</code>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这就是一个<code>vuex</code>的最简单实例，<code>store</code>就是组件中的共享状态，而改变状态的方法(其实是一个对象包含很多方法，但都是来改变<code>store</code>的)叫做:<code>mutations</code>；<br> 需要特变注意的是只能通过<code>mutations</code>改变<code>store</code>的<code>state</code>的状态，不能通过<code>store.state.count = 5</code>;直接更改（其实可以更改，不建议这么做，不通过<code>mutations</code>改变<code>state</code>，状态不会被同步）。<br> 使用<code>store.commit</code>方法触发<code>mutations</code>改变<code>state</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">store.commit(&apos;increment&apos;);</span><br><span class="line">console.log(store.state.count)  // 1</span><br></pre></td></tr></table></figure>
<p> 这样一个简简单单的Vuex应用就实现了。 </p>
<h3 id="在Vue组件里使用Vuex"><a href="#在Vue组件里使用Vuex" class="headerlink" title="在Vue组件里使用Vuex"></a>在<code>Vue</code>组件里使用<code>Vuex</code></h3><p> <code>Vuex</code>的状态获取是一个方法，当<code>Vuex</code>状态更新时，相应的<code>Vue</code>组件也要更新，所以<code>Vue</code>应该在计算属性（<code>computed</code>）获取<code>state</code>； </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return store.state.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面的例子是直接操作全局状态<code>store.state.count</code>，那么每个使用该<code>Vuex</code>的组件都要引入。为了解决这个，<code>Vuex</code>通过<code>store</code>选项，提供了一种机制将状态从根组件注入到每一个子组件中。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 根组件</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex form &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    store,</span><br><span class="line">    components: &#123;</span><br><span class="line">        Counter</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `</span><br><span class="line">        &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">            &lt;counter&gt;&lt;/counter&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 通过这种注入机制，就能在子组件<code>Counter</code>通过<code>this.$store</code>访问： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Counter 组件</span><br><span class="line">const Counter = &#123;</span><br><span class="line">    template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        count () &#123;</span><br><span class="line">            return this.$store.state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mapState函数"><a href="#mapState函数" class="headerlink" title="mapState函数"></a><code>mapState</code>函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">        return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这样通过<code>count</code>计算属性获取同名<code>state.count</code>属性，是不是显得太重复了，我们可以使用<code>mapState</code>函数简化这个过程。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mapState &#125; from &apos;vuex&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: state =&gt; state.count,</span><br><span class="line">        countAlias: &apos;count&apos;,    // 别名 `count` 等价于 state =&gt; state.count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 还有更简单的使用方法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &apos;count&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h5 id="Getters对象"><a href="#Getters对象" class="headerlink" title="Getters对象"></a><code>Getters</code>对象</h5><p> 如果我们需要对<code>state</code>对象进行做处理计算，如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        return this.$store.state.todos.filter(todo =&gt; todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数。这样是很没有效率的事情，当这个处理过程更改了，还有在多个组件中进行同样的更改，这就更加不易于维护。</p>
<p><code>Vuex</code>中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理。<code>Getters</code>接受<code>state</code>作为第一个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; id: 1, text: &apos;...&apos;, done: true &#125;,</span><br><span class="line">      &#123; id: 2, text: &apos;...&apos;, done: false &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 在<code>Vue</code>中通过<code>store.getters</code>对象调用。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodos () &#123;</span><br><span class="line">    return this.$store.getters.doneTodos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>Getter</code>也可以接受其他<code>getters</code>作为第二个参数： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: state =&gt; &#123;</span><br><span class="line">      return state.todos.filter(todo =&gt; todo.done)</span><br><span class="line">  &#125;,</span><br><span class="line">  doneTodosCount: (state, getters) =&gt; &#123;</span><br><span class="line">    return getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue之路第一篇</title>
    <url>/2018/07/15/Vue%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    <content><![CDATA[<h4 id="1、开发工具选择"><a href="#1、开发工具选择" class="headerlink" title="1、开发工具选择"></a>1、开发工具选择</h4><p> 这个和个人的开发习惯有关，并不做强求，厉害的话用记事本也可以。但是我还是建议用人气比较高的编辑工具，毕竟功能比较全面，开发起来效率比较高。 </p><p>Visual Studio Code：一个运行于 Mac OS X、<a href="https://baike.baidu.com/item/Windows" target="_blank" rel="noopener">Windows</a>和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。</p><a id="more"></a>

<p>Visual Studio Code 官方免费下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noopener">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p>
<p>另外说一句 VS yyds！！！！</p>
<h4 id="2、Vue安装"><a href="#2、Vue安装" class="headerlink" title="2、Vue安装"></a>2、Vue安装</h4><p> 直接下载并用  script 标签引入，Vue会被注册为一个全局变量。 </p>
<p>开发版本链接：<a href="https://cn.vuejs.org/js/vue.js" target="_blank" rel="noopener">https://cn.vuejs.org/js/vue.js</a></p>
<p>生产版本链接：<a href="https://cn.vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://cn.vuejs.org/js/vue.min.js</a></p>
<p>CDN：</p>
<p>对于学习 我们可以这样使用最新版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue之路第二篇</title>
    <url>/2018/07/16/Vue%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
    <content><![CDATA[<h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><p>1、首先创建一个html页面 导入Vue 包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js/vue.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p> 每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的： </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"> &lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       el : <span class="string">"#app"</span>,</span><br><span class="line">       data : &#123;</span><br><span class="line">            msg : <span class="string">"Hello Vue"</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p> 通过new的方式创建了一个Vue对象，对象包含了 el 和 data两个属性(这一篇只涉及这两个属性)，</p>
<p>“el” 是用来绑定元素节点的，对应的是id为app的元素节点</p>
<p>“data” 是Vue对象里绑定的数据，采用的 key-value形式定义。展示数据的时候采用的是插值表达式 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue双向数据绑定v-model指令</title>
    <url>/2018/07/18/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。"><a href="#双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。" class="headerlink" title="双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。"></a>双向数据绑定可以简单理解为：后端定义的数据改变，前端页面展示的时候会自动改变，数据通过前端页面修改的时候，后端定义的数据内容也会随之改变。</h3><p>指令中v-model可以实现双向数据绑定。</p><p>v-model只能应用在表单元素中，如：input（radio、text、address、email…）、checkbox、select、textarea等。</p><a id="more"></a>

<h3 id="看例子"><a href="#看例子" class="headerlink" title="看例子"></a>看例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-bind:value</span>=<span class="string">"msg"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;</span><br><span class="line"><span class="javascript">                msg : <span class="string">'This is a msg'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods : &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候我们 打开浏览器控制台输入：vm.msg，按下enter键查看对象属性。</p>
<p>“This is a msg”</p>
<p>接下来在控制台执行一条语句：vm.msg = 123 ，对msg数据重新赋值</p>
<p>123</p>
<p>可以看到我们在赋值的同时，页面的数据也随之发生了变化；那么我们再试试改变页面展示的数据，看看msg后台数据会不会发生变化。</p>
<p>先在页面input框里加上了“aaa”，然后在页面控制台中输入vm.msg查看，发现其值没有发生变化，还是“123”，这就是数据单向绑定。</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到我们连input框的value元素都不用写，直接用v-model指令即可，其值会默认赋值在value属性上（这也是为什么v-model仅局限于表单元素使用的原因）。</p>
<p>我们先在浏览器控制台中做赋值：vm.msg = 123，观察到页面数据也会随之变化。</p>
<p> 然后我们在输入框中加上“神奇”二字，会发现input框上面的h4标签的文字会随之变化，控制台输入：vm.msg，其对象值也发生了变化，这就是双向数据绑定。 </p>
<h3 id="v-model指令后面还可以添加参数"><a href="#v-model指令后面还可以添加参数" class="headerlink" title="v-model指令后面还可以添加参数"></a>v-model指令后面还可以添加参数</h3><p> lazy：将数据变化改到change事件中发生 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在v-model后加上了“.lazy”，这时我们在Input框里输入内容的时候，h4标签的内容不会马上变化，只有当输入完毕，光标不再聚焦于input框的时候，值才会同步，相当于change事件触发时才会同步数据。还有一些参数，比如：number、debounce</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue事件修饰符</title>
    <url>/2018/07/18/Vue%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p> 顾名思义，“事件修饰符”那么肯定是用来修饰事件，既然和事件有关系，那么肯定和“v-on”指令也可简写为：@ 有关系。 </p><p>事件修饰符有以下几类：</p><p>.stop：阻止冒泡</p><p>.prevent：阻止默认事件</p><p>.capture：事件捕获</p><p>.self：只当事件在该元素本身触发时触发回调</p><p>.once：事件只触发一次</p><h3 id="1、阻止冒泡"><a href="#1、阻止冒泡" class="headerlink" title="1、阻止冒泡"></a>1、阻止冒泡</h3><a id="more"></a>






<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"clickDiv()"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickButton()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>样式代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#715F5F</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">　　　　 <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>JS</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el : <span class="string">"#app"</span>,</span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">                clickDiv()&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'点击了div'</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                clickButton()&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'点击了button'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p> 当点击按钮的时候，浏览器控制台除了会输出“点击了button”还会输出“点击了div”，这是因为button按钮是div里的元素节点，当你点击button的时候，事件会向上冒泡，触发包含它的父元素所定义的事件，这就是冒泡事件。如果想阻止冒泡事件就需用到“.stop”修饰符。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"clickButton"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时再点击按钮不会触发点击父元素div的事件。</p>
<h3 id="2、阻止默认事件"><a href="#2、阻止默认事件" class="headerlink" title="2、阻止默认事件"></a>2、阻止默认事件</h3><p>什么是默认事件？如：点击a链接自动进行跳转、点击submit按钮自动提交表单等。我们以a链接为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"linkClick()"</span>&gt;</span>有问题，先百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">                linkClick()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'点击了a链接'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 加上.prevent修饰符后，a链接不能进行跳转，但是仍然可以触发click事件。 </p>
<h3 id="3、事件捕获"><a href="#3、事件捕获" class="headerlink" title="3、事件捕获"></a>3、事件捕获</h3><p> 还记得冒泡事件中触发的顺序吗？即：先触发button按钮的点击事件，然后会触发button父元素div的点击事件；如果我想点击button之后先触发父元素div的点击事件，然后再触发子元素button的点击事件呢？ </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.capture</span>=<span class="string">"clickDiv"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickButton"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 即：在事件触发中进行捕获，优先执行含有“.capture”修饰符的事件。 </p>
<h3 id="4、只当事件在该元素本身触发时触发回调"><a href="#4、只当事件在该元素本身触发时触发回调" class="headerlink" title="4、只当事件在该元素本身触发时触发回调"></a>4、只当事件在该元素本身触发时触发回调</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.self</span>=<span class="string">"clickDiv"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"clickButton"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 我们在父元素div里加了“.self”，这样父元素的点击事件只有在点击自身元素的情况下才可以触发，点击其他的任何元素（如子元素button）都不会触发包含修饰符“.self”的元素事件。 </p>
<h3 id="5、事件只触发一次"><a href="#5、事件只触发一次" class="headerlink" title="5、事件只触发一次"></a>5、事件只触发一次</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> @<span class="attr">click.prevent.once</span>=<span class="string">"clickLink()"</span>&gt;</span>有问题，去百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">                clickLink()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'点击了a链接'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的修饰符“.once”的作用是让默认阻止行为（.prevent）只生效一次，所以当我们第一次点击a链接的时候，浏览器控制台会输出“点击了a链接”，但是页面不会跳转，当我们再次点击a链接的时候页面会跳转到百度页面，这就是”.once”修饰符的作用。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue子组件向父组件传值</title>
    <url>/2018/08/14/Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><ol>
<li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li>
<li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称</li>
</ol><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br></pre></td></tr></table></figure>
<p>3、子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 引用父组件 --&gt;</span><br><span class="line">    &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 组件模板定义 --&gt;</span><br><span class="line">    &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 子组件的定义方式</span><br><span class="line">    Vue.component(&apos;son&apos;, &#123;</span><br><span class="line">      template: &apos;#son&apos;, // 组件模板Id</span><br><span class="line">      methods: &#123;</span><br><span class="line">        sendMsg() &#123; // 按钮的点击事件</span><br><span class="line">          this.$emit(&apos;func&apos;, &apos;OK&apos;); // 调用父组件传递过来的方法，同时把数据传递出去</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义</span><br><span class="line">          alert(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue实例的生命周期函数</title>
    <url>/2018/08/02/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h2><ul>
<li><p>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</p>
</li>
<li><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p>
</li>
<li><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p>
<h3 id="主要的生命周期函数分类："><a href="#主要的生命周期函数分类：" class="headerlink" title="主要的生命周期函数分类："></a>主要的生命周期函数分类：</h3></li>
</ul><h4 id="创建期间的生命周期函数："><a href="#创建期间的生命周期函数：" class="headerlink" title="创建期间的生命周期函数："></a>创建期间的生命周期函数：</h4><ul>
<li>beforeCreate：刚初始化一个Vue空的实例对象，这个对象上只有一些生命周期函数和默认的事件，此时，还没有初始化好 data 和 methods 的数据</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板（如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作）</li>
<li>beforeMount：开始编辑模板 在内存中生成一个编译好的最终模板字符串，然后渲染为内存中的DOM，此时已经完成了模板的编译，但是还没有挂载到真正的页面中</li>
<li>mounted：此时，表示整个Vue实例已经初始化完毕了，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ul><a id="more"></a>

<h4 id="运行期间的生命周期函数："><a href="#运行期间的生命周期函数：" class="headerlink" title="运行期间的生命周期函数："></a>运行期间的生命周期函数：</h4><ul>
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ul>
<h4 id="销毁期间的生命周期函数："><a href="#销毁期间的生命周期函数：" class="headerlink" title="销毁期间的生命周期函数："></a>销毁期间的生命周期函数：</h4><ul>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。实例身上所有的data和所有的methods以及过滤器、指令….都处于可用状态，还没有真正执行销毁的过程</li>
<li>destroyed：Vue 实例销毁后调用。已经完全被销毁，此时实例所有的数据、方法、指令过滤器都不可用了</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令V-for</title>
    <url>/2018/07/23/Vue%E6%8C%87%E4%BB%A4V-for/</url>
    <content><![CDATA[<p>v-for指令，看名字想必大家也能猜到其作用，没错，就是用来迭代、遍历的。</p><h3 id="1、简单数组的遍历"><a href="#1、简单数组的遍历" class="headerlink" title="1、简单数组的遍历"></a>1、简单数组的遍历</h3><p> 我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span>&#123;&#123;item&#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                list:[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>,<span class="string">'five'</span>]</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>data里定义了list字符串数组，在页面中使用v-for指令对list进行遍历，”item”是当前正在遍历的元素对象，“in”是固定语法，“list”是被遍历的数组。用插值表达式来展示当前遍历的对象。</p>
<p>有时除了遍历数据外，我们还需要当前遍历的序号：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item,i) in list"</span>&gt;</span>序号为：&#123;&#123;i&#125;&#125;，元素为：&#123;&#123;item&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> （Item,i）其中i为序号，当然i和item是临时变量可以任意定义。</p>
<h3 id="2、对象数组的遍历"><a href="#2、对象数组的遍历" class="headerlink" title="2、对象数组的遍历"></a>2、对象数组的遍历</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item,i) in list"</span>&gt;</span>序号：&#123;&#123;i&#125;&#125;，科目为：&#123;&#123;item.course&#125;&#125;，分数为：&#123;&#123;item.score&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                list:[</span><br><span class="line"><span class="javascript">                    &#123;<span class="string">'course'</span>:<span class="string">'语文'</span>, <span class="string">'score'</span>:<span class="number">89</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">'course'</span>:<span class="string">'数学'</span>, <span class="string">'score'</span>:<span class="number">80</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="string">'course'</span>:<span class="string">'英语'</span>, <span class="string">'score'</span>:<span class="number">90</span>&#125;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 通过”item.score”的方法，来获取对象的属性值。</p>
<h3 id="3、遍历对象"><a href="#3、遍历对象" class="headerlink" title="3、遍历对象"></a>3、遍历对象</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in mark"</span>&gt;</span>属性名：&#123;&#123;key&#125;&#125;，属性值：&#123;&#123;value&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                mark:&#123;</span><br><span class="line"><span class="javascript">                    <span class="string">'语文'</span>:<span class="number">90</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'数学'</span>:<span class="number">95</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'英语'</span>:<span class="number">89</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个mark对象，该对象有三个属性，遍历对象的时候固定写法为：(XX,YY)，其中YY为对象的key，XX为对象的值。 当然也可以写成：(XX,YY,i)，其中i为索引值。 </p>
<h3 id="4、遍历数字"><a href="#4、遍历数字" class="headerlink" title="4、遍历数字"></a>4、遍历数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;divi id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;span v-for=&quot;count in 5&quot;&gt;当前数字为：&#123;&#123;count&#125;&#125;&lt;br&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p> 这里in后面直接写的是具体的数字 。</p>
<h3 id="5、维护状态"><a href="#5、维护状态" class="headerlink" title="5、维护状态"></a>5、维护状态</h3><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code>。</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
<p> 不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令v-if和v-show</title>
    <url>/2018/07/23/Vue%E6%8C%87%E4%BB%A4v-if%E5%92%8Cv-show/</url>
    <content><![CDATA[<h3 id="v-if和v-show都是用来实现条件判断的指令。"><a href="#v-if和v-show都是用来实现条件判断的指令。" class="headerlink" title="v-if和v-show都是用来实现条件判断的指令。"></a>v-if和v-show都是用来实现条件判断的指令。</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"reverse()"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span>这是v-if指令控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span>这是v-show指令控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                flag:<span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                reverse()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>
<p>当页面元素隐藏或者显示的时候，v-if每次都会重新删除或创建元素，v-show指令则通过控制样式属性display的值来实现同样的效果。</p>
<p>总结：</p>
<p>v-if由于每次都会重新删除或创建元素，所以有较高的切换性能消耗。</p>
<p>v-show通过控制样式属性display的值来显示隐藏元素，但是即使你不需要显示，该元素还是被页面渲染了，所以其有较高的初始渲染消耗。</p>
<p>具体使用哪一个还是要根据实际的业务场景来判断使用。</p>
<p>如果元素涉及到频繁的切换，最好不要使用<code>v-if</code>,如果元素可能永远也不会被显示出来被用户看到则推荐使用<code>v-if</code> </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令v-on</title>
    <url>/2018/07/17/Vue%E6%8C%87%E4%BB%A4v-on/</url>
    <content><![CDATA[<p> v-on指令用来触发页面事件的指令。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"show()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">'aa'</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>如上代码，指令书写格式为：v-on:事件名称，不要忘记书写:，等于号后面的内容是Vue对象里声明的方法。</p>
<p>在Vue对象里，我们添加了一个新的属性，叫做methods，它用来声明方法对象，其中show即为我们声明的方法对象。</p>
<p> 在Vue中，我们还可以对v-on进行简化，用@来代替，效果是一样的，代码如下所示： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&quot;show()&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>除了click事件，我们还可以定义其他的一些常用事件，如：</p>
<p>mouseover：鼠标放上事件</p>
<p>mouseout：鼠标移开事件</p>
<p>change：内容改变</p>
<p>dblclick：双击事件</p>
<p>focus：聚焦事件</p>
<p>blur：失去焦点事件</p>
<p>等等等……</p>
<p>es6方法定义新写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前的写法</span></span><br><span class="line">show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'aa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Es6的新写法</span></span><br><span class="line">show()&#123;</span><br><span class="line">    alert(<span class="string">'aa'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue按键修饰符</title>
    <url>/2018/07/26/Vue%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>  在监听键盘事件时，我们经常需要监听常见的键值，vue允许v-on在监听键盘事件时添加按键修饰符： </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">divi</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        序号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"idValue"</span>/&gt;</span></span><br><span class="line">        车名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"nameValue"</span> @<span class="attr">keyup.enter</span>=<span class="string">"add()"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">           序号：&#123;&#123;item.id &#125;&#125; , 车名：&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                idValue:<span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">                nameValue:<span class="string">''</span>,</span></span><br><span class="line">                list:[</span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'奥迪'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'宝马'</span>&#125;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                add()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.list.unshift(&#123;</span></span><br><span class="line"><span class="javascript">                        id : <span class="keyword">this</span>.idValue,</span></span><br><span class="line"><span class="javascript">                        name : <span class="keyword">this</span>.nameValue</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p> 这里在车名的input框里添加keyup事件，即键盘按下抬起时触发；后面的“enter”即为按键修饰符，定义哪个按键会触发该事件。所以当光标位于该input框时，按下Enter键抬起就会触发事件执行add方法，并添加新数据展示在页面上。 </p>
<p> 除了enter键以外，vue还定义了以下按键修饰符：tab、delete (捕获“删除”和“退格”键)、esc、space、up、down、left、right；这些是官网提供的修饰符，但是实际进行操作的时候发现，几乎所有的键盘按键都可以用来作为修饰符。</p>
<p> 除了使用以上方法，我们还可以使用keycode（键盘码）来作为修饰符使用。如：f2的键盘码为113，我们可以修改代码为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">车名：&lt;input type=&quot;text&quot; v-model=&quot;nameValue&quot; @keyup.113=&quot;add()&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>这时光标在input框时，我们按下再松开f2时也可以触发事件。</p>
<p>注：不管是使用键盘名称还是使用键盘码都要防止快捷键的冲突，快捷键冲突的时候会不起作用。</p>
<p>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.keyCodes.f2 = 113;</span><br></pre></td></tr></table></figure>
<p>使用自定义的按键修饰符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue注册局部子组件</title>
    <url>/2018/08/12/Vue%E6%B3%A8%E5%86%8C%E5%B1%80%E9%83%A8%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><p>1、组件实例定义方式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      methods: &#123;&#125;,</span><br><span class="line">      components: &#123; </span><br><span class="line">        account: &#123; </span><br><span class="line">          template: &apos;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>2、引用组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">account</span>&gt;</span><span class="tag">&lt;/<span class="name">account</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h3><ol>
<li><p>页面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt;</span><br><span class="line">    &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt;</span><br><span class="line">    &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.Vue实例内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&apos;myCom1&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h3&gt;奔波霸&lt;/h3&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue.component(&apos;myCom2&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;h3&gt;霸波奔&lt;/h3&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        flag: true</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用-is属性来切换不同的子组件"><a href="#使用-is属性来切换不同的子组件" class="headerlink" title="使用:is属性来切换不同的子组件"></a>使用<code>:is</code>属性来切换不同的子组件</h3><p>1、组件实例定义方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录组件</span></span><br><span class="line">   <span class="keyword">const</span> login = Vue.extend(&#123;</span><br><span class="line">     template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">       &lt;h3&gt;登录组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;`</span></span><br><span class="line">   &#125;);</span><br><span class="line">   Vue.component(<span class="string">'login'</span>, login);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册组件</span></span><br><span class="line">   <span class="keyword">const</span> register = Vue.extend(&#123;</span><br><span class="line">     template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">       &lt;h3&gt;注册组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">     &lt;/div&gt;`</span></span><br><span class="line">   &#125;);</span><br><span class="line">   Vue.component(<span class="string">'register'</span>, register);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     el: <span class="string">'#app'</span>,</span><br><span class="line">     data: &#123; <span class="attr">comName</span>: <span class="string">'login'</span> &#125;,</span><br><span class="line">     methods: &#123;&#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>2、使用<code>component</code>标签，来引用组件，并通过<code>:is</code>属性来指定要加载的组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='login'"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='register'"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"comName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue第五篇指令v-bind</title>
    <url>/2018/07/16/Vue%E7%AC%AC%E4%BA%94%E7%AF%87%E6%8C%87%E4%BB%A4v-bind/</url>
    <content><![CDATA[<p>v-bind：是Vue提供的用于绑定html属性的指令。</p><p>html中常见的属性有：id、class、src、title、style等，他们都是以 名称/值对 的形式出现，如：id=”first”</p><p>本篇的内容主要是介绍使用v-bind指令动态给这些属性赋值。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"path"</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;</span><br><span class="line"><span class="javascript">                path : <span class="string">"img/clock.png"</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>



<p>主要分为两个模块：定义了一个Img标签，它的src属性值通过v-bind指令从Vue对象中获取；js代码定义了Vue对象，并声明了data数据。</p>
<p> v-bind的一种简写形式，那就是我们在实际传递属性值数据的时候可以不写“v-bind”只留属性名称前面的冒号:即可。 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue父组件向子组件传值</title>
    <url>/2018/08/14/Vue%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>1、组件实例定义方式，注意：一定要使用<code>props</code>属性来定义父组件传递过来的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例，得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        msg: &apos;这是父组件中的消息&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        son: &#123;</span><br><span class="line">          template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;,</span><br><span class="line">          props: [&apos;finfo&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>2、使用<code>v-bind</code>或简化指令，将数据传递到子组件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue组件的注册</title>
    <url>/2018/08/12/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h3 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h3><p>什么是组件： 组件的出现，就是为了拆分<code>Vue</code>的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul>
<li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li>
<li>组件化： 是从<code>UI</code>界面的角度进行划分的；前端的组件化，方便<code>UI</code>组件的重用；</li>
</ul><a id="more"></a>

<h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3><p>1、使用<code>Vue. extend</code>配合<code>Vue.component</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> login=Vue.extend(&#123;</span><br><span class="line">		template:<span class="string">'&lt;h1&gt;登陆组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line">		Vue.component(<span class="string">'login'</span>,login)</span><br></pre></td></tr></table></figure>
<p>2、直接使用<code>Vue.component</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'register'</span>,&#123;</span><br><span class="line">		template:<span class="string">'&lt;h1&gt;注册组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3、将模板字符串，定义到<code>script</code>标签中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;</span><br><span class="line">      &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>同时需要使用<code>Vue.component</code>来注册组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;account&apos;,&#123;</span><br><span class="line">		template:&apos;#tmp1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意： 组件中的<code>DOM</code>结构，有且只能有唯一的根元素（<code>Root Element</code>）来进行包裹！</p>
<h3 id="组建中展示数据和响应事件"><a href="#组建中展示数据和响应事件" class="headerlink" title="组建中展示数据和响应事件"></a>组建中展示数据和响应事件</h3><p>1、在组件中，<code>data</code>需要被定义为一个方法</p>
<p> 组件中的<code>data</code>写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份<code>data</code>，就会造成一个变了全都会变的结果。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'account'</span>, &#123;</span><br><span class="line">      template: <span class="string">'#tmpl'</span>,</span><br><span class="line">      data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          msg: <span class="string">'大家好！'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        login()&#123;</span><br><span class="line">          alert(<span class="string">'点击了登录按钮'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>2、在子组件中。如果将模板字符串定义到了<code>script</code>标签中了，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue第四篇指令v-html</title>
    <url>/2018/07/16/Vue%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%8C%87%E4%BB%A4v-html/</url>
    <content><![CDATA[<h3 id="指令v-html"><a href="#指令v-html" class="headerlink" title="指令v-html"></a>指令v-html</h3><p>如果我们展示的数据包含元素标签或者样式，我们想展示标签或样式所定义的属性作用，该怎么进行渲染</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">           el : <span class="string">"#app"</span>,</span></span><br><span class="line">           data : &#123;</span><br><span class="line"><span class="xml">               msg : "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个h1元素内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>"</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>  就可以成功解析标签。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue自定义指令</title>
    <url>/2018/07/27/Vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>在vue2.0中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。</p><p>自定义指令最重要的两个部分就是钩子函数和钩子函数对应的参数。</p><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><p><strong>bind：</strong>只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。</p><a id="more"></a>



<p><strong>inserted：</strong>被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p><strong>update：</strong>所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>
<p><strong>componentUpdated：</strong>指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>
<p><strong>unbind：</strong>只调用一次，指令与元素解绑时调用。</p>
<h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><p>指令钩子函数会被传入以下参数：</p>
<p>el：指令所绑定的元素，可以用来直接操作 DOM 。<br>binding：一个对象，包含以下属性：<br>name：指令名，不包括 v- 前缀。<br>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1”中，表达式为 “1 + 1”。<br>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。<br>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。<br>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue1.0中提供了一个Vue.directive(自定义指令名称，回调函数)来供程序员自定义指令</span></span><br><span class="line"><span class="comment">//注意:在定义指令时不需要加v-前缀但是使用时必须加v-前缀</span></span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 聚焦元素</span></span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个v-color指令</span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素被绑定时</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>) </span>&#123;</span><br><span class="line">        el.style.color = binding.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>使用自定义指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus v-color=&quot;customColor&quot; placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="自定义私有指令"><a href="#自定义私有指令" class="headerlink" title="自定义私有指令"></a>自定义私有指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">    el: &apos;#app-4&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">	directives: &#123;</span><br><span class="line">        focus: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            inserted: function(el) &#123;</span><br><span class="line">                el.focus()</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 使用自定义元素 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-focus placeholder=&quot;请输入筛选条件&quot; v-model=&quot;searchtext&quot; /&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue计算属性</title>
    <url>/2018/08/16/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p> 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串。当你想要在模板中的多处包含此翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。 </p>
<p>表达式里面包含了3个操作，有时候可能会更加复杂，这时我们可以使用计算属性。如下 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123;reversedText&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                text: &apos;123,456&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            reversedText: function () &#123;</span><br><span class="line">                //这里的this指向的是当前的vue实例</span><br><span class="line">                return this.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;);  //如果这两的text是后台接受的数据，最好加个判断数据为不为空</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 所有计算属性都以函数的形式写在<code>Vue</code>实例内的<code>computed</code>选项内，最终返回计算后的结果 </p>
<h3 id="计算属性用法"><a href="#计算属性用法" class="headerlink" title="计算属性用法"></a>计算属性用法</h3><p>在一个计算属性里可以完成各种复杂的逻辑，包括逻辑运算、函数调用等，只要最终返回一个结果就可以。除了上面的简单的用法，计算属性还可以依赖多个<code>vue</code>实例的数据，只要其中任意一个数据变化，计算属性就会重新执行，视图也会更新，例如下面的例子展示的是购物车内两个包裹的物品总价 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;prices&quot;&gt;</span><br><span class="line">         总价： &#123;&#123;prices&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">       // &lt;!--购物车总价--&gt;</span><br><span class="line">        var prices = new Vue(&#123;</span><br><span class="line">            el: &quot;#prices&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                package1: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为mate20pro&quot;,</span><br><span class="line">                    price: 4566,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;华为p30&quot;,</span><br><span class="line">                    price: 4166,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                ],</span><br><span class="line">                package2: [</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;苹果&quot;,</span><br><span class="line">                    price: 30,</span><br><span class="line">                    count: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name: &quot;香蕉&quot;,</span><br><span class="line">                    price: 2,</span><br><span class="line">                    count: 20</span><br><span class="line">                &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                prices: function () &#123;</span><br><span class="line">                    var prices = 0;</span><br><span class="line">                    debugger</span><br><span class="line">                    for (var i = 0; i &lt; this.package1.length; i++) &#123;</span><br><span class="line">                        prices += this.package1[i].price * this.package1[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (var i = 0; i &lt; this.package2.length; i++) &#123;</span><br><span class="line">                        prices += this.package2[i].price * this.package2[i].count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return prices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 当package1或package2中的商品发生变化，比如购买数量变化或者增删商品时，计算属性prices就会自动更新，视图中的总价也会自动变化<br>每个计算属性都包含一个getter和setter，上面的例子都是计算属性默认用法，只是利用了getter来读取。在你需要时，也可以提供一个setter函数，当手动修改计算属性的值就像修改一个普通数据那样，就会触发setter函数，执行一些自定义的操作。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--setter--&gt;</span><br><span class="line">        &lt;div id=&quot;setter&quot;&gt;</span><br><span class="line">         姓名： &#123;&#123;fullName&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> var setter = new Vue(&#123;</span><br><span class="line">            el: &quot;setter&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                firstName: &apos;Jack&apos;,</span><br><span class="line">                lastName:&apos;Green&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                fullName: &#123;</span><br><span class="line">                    //getter,用于读取</span><br><span class="line">                    get: function ()</span><br><span class="line">                    &#123;</span><br><span class="line">                        return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">                    &#125;,</span><br><span class="line">                    //setter，写入时触发</span><br><span class="line">                    set: function (newValue)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var names = newValue.split(&apos; &apos;);</span><br><span class="line">                        this.firstName = names[0];</span><br><span class="line">                        this.lastName = names[1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 当执行 setter.fullName=’Join Doe’时候，setter就会被调用，数据firstName和lastName都会相对更新，视图同样也会更新<br>    绝大多情况下，我们只会使用默认的getter方法来读取一个计算属性，在业务中很少使用到setter，所以在声明一个计算属性的时候，可以直接使用默认的写法，不必将getter和setter都声明<br>   计算属性除啦以上简单的文本插值外，还经常用于动态的设置元素的样式名称class和内联样式style，当使用组件时，计算属性也经常用来动态传递props以后，我会慢慢介绍到<br>计算属性还有两个很使用的小技巧很容易被忽略，一是计算属性可以依赖其他计算属性，二是计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他Vue实例的数据 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app1&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;div id=&quot;app2&quot;&gt;</span><br><span class="line">         &#123;&#123;reversedText&#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        var app1 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app1&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: &quot;123,456&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var app2 = new Vue(&#123;</span><br><span class="line">            el: &quot;#app2&quot;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                reversedText: function () &#123;</span><br><span class="line">                    //这里是依赖app1实例中的数据text</span><br><span class="line">                    return app1.text.split(&apos;,&apos;).reverse().join(&apos;,&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 这里我们创建了两个vue实例app1和app2，在app2的计算属性reversedText中，依赖的是app1的数据text，所以当text变化时，实例app2的计算属性也会变化，这样的用法以后用到的也会比较多，尤其是在多人协同开发时很常用，以为你写的组件所用到的数据需要依赖他人的组件提供，以后接触的多了就会慢慢的意识到这一点。 </p>
<h3 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a><strong>计算属性缓存</strong></h3><p> 其实细心的话就会发现，调用methods里的方法也能实现和计算属性一样的效果，甚至有的方法还能接收参数，使用起来更加的灵活，既然使用methods就可以实现，那为什么还需要计算属性呢？原因就是计算属性是基于他的依赖缓存的。一个计算属性所依赖的数据发生变化时，他才会重新取值，<br>所以依赖的text只要不改变。计算属性也就不更新 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed：&#123;</span><br><span class="line">now：function()</span><br><span class="line"> 	&#123;</span><br><span class="line">		return Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里的<code>Date.now()</code>不是响应式依赖，所以计算属性<code>now</code> 不会更新，但是<code>methods</code>则不同，只要重新渲染他就会被调用，因此函数也会被执行。<br>使用计算属性还是<code>methods</code>取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存 </p>
<p><code>methods</code>和计算属性<code>computed</code> 实现的最终效果其实是一样的，然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 数据  没有发生改变，多次访问 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用<code>methods</code>方法将总会再次执行函数。</p>
<p>计算属性的求值结果会被缓存起来，方便下次直接使用，如果计算属性方法中所依赖的任何数据都没有发生过改变，则不会重新对计算属性求值。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue过渡、动画</title>
    <url>/2018/08/05/Vue%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p><p> Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 </p><ul>
<li>在 CSS 过渡和动画中自动应用 class</li>
<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
</ul><a id="more"></a>


<h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><p>HTML结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"动起来"</span> @<span class="attr">click</span>=<span class="string">"myAnimate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>VM实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    isshow: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    myAnimate() &#123;</span><br><span class="line">      <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>定义两组类样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义进入和离开时候的过渡状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter-active</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.2s</span> ease;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义进入过渡的开始状态 和 离开过渡的结束状态 */</span></span><br><span class="line">    <span class="selector-class">.fade-enter</span>,</span><br><span class="line">    <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用第三方CSS动画库"><a href="#使用第三方CSS动画库" class="headerlink" title="使用第三方CSS动画库"></a>使用第三方CSS动画库</h3><p>1、导入动画类库：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./lib/animate.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、定义 transition 及属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">	<span class="attr">enter-active-class</span>=<span class="string">"fadeInRight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">"fadeOutRight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"animated"</span> <span class="attr">v-show</span>=<span class="string">"isshow"</span>&gt;</span>动画哦<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><p>1、定义 transition 组件以及三个钩子函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"切换动画"</span> @<span class="attr">click</span>=<span class="string">"isshow = !isshow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">before-enter</span>=<span class="string">"beforeEnter"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">after-enter</span>=<span class="string">"afterEnter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"isshow"</span> <span class="attr">class</span>=<span class="string">"show"</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、定义三个 methods 钩子方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        beforeEnter(el) &#123; <span class="comment">// 动画进入之前的回调</span></span><br><span class="line">          el.style.transform = <span class="string">'translateX(500px)'</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        enter(el, done) &#123; <span class="comment">// 动画进入完成时候的回调</span></span><br><span class="line">          el.offsetWidth;</span><br><span class="line">          el.style.transform = <span class="string">'translateX(0px)'</span>;</span><br><span class="line">          done();</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter(el) &#123; <span class="comment">// 动画进入完成之后的回调</span></span><br><span class="line">          <span class="keyword">this</span>.isshow = !<span class="keyword">this</span>.isshow;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>3、定义动画过渡时长和样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.show</span>&#123;</span><br><span class="line">      <span class="attribute">transition</span>: all <span class="number">0.4s</span> ease;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>dd</title>
    <url>/2021/06/11/dd/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ddsas</title>
    <url>/2021/06/11/ddsas/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>src与href的区别</title>
    <url>/2018/09/10/src%E4%B8%8Ehref%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p> src和href都是用于外部资源的引入，像图片、CSS文件、HTML文件、js文件或其他web页面等。 </p><p>引用css文件时：<code>href=&quot;cssfile.css&quot;</code> </p><p>引用js文件时：<code>src=&quot;myscript.js&quot;</code> </p><p>引用图片：<code>src=&quot;mypic.jpg&quot;</code> </p><a id="more"></a>



<p>网站链接：<code>href=&quot;http://www.webpage.com&quot;</code></p>
<p><strong>它们之间的主要区别可以用这样一句话来概括：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系。</strong> </p>
<p> <strong>href (Hypertext Reference) 超文本引用</strong><code>href</code>这个属性指定<code>web</code>资源的位置，从而定义当前元素（如锚点<code>a</code>）或当前文档（如链接）与目标锚点或目标资源之间的联系。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器知道这是个样式表文件，html的解析和渲染不会暂停，css文件的加载是同时进行的，这不同于在style标签里面的内置样式，用@import添加的样式是在页面载入之后再加载，这可能会导致页面因重新渲染而闪烁。所以我们建议使用<code>link</code>而不是<code>@import</code>。</p>
<h3 id="补充：link和-import的区别"><a href="#补充：link和-import的区别" class="headerlink" title="补充：link和@import的区别"></a>补充：<code>link</code>和@<code>import</code>的区别</h3><p>两者都是外部引用<code>CSS</code>的方式，但是存在一定的区别：</p>
<p>1、<code>link</code>是<code>XHTML</code>标签，除了加载<code>CSS</code>外，还可以定义<code>RSS</code>等其他事务；<code>@import</code>属于<code>CSS</code>范畴，只能加载<code>CSS</code>。</p>
<p>2、<code>link</code>引用<code>CSS</code>时，在页面载入时同时加载；@<code>import</code>需要页面网页完全载入以后加载。</p>
<p>3、<code>link</code>是<code>XHTML</code>标签，无兼容问题；@<code>import</code>是在<code>CSS2.1</code>提出的，低版本的浏览器不支持。</p>
<p>4、<code>link</code>支持使用<code>Javascript</code>控制<code>DOM</code>去改变样式；而<code>@import</code>不支持。</p>
<p> <strong>src (Source)源</strong>这个属性是将资源嵌入到当前文档中元素所在的位置。 在请求<code>src</code>资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。 例如当我们写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个<code>js</code>文件。这就像是把<code>js</code>文件里的内容全部注入到这个<code>script</code>标签中，类似于<code>img</code>，<code>img</code>标签是一个空标签，它的内容就是由<code>src</code>这个属性定义，浏览器会暂停加载直到这个图片加载完成。这也是为什么要将<code>js</code>文件的加载放在<code>body</code>最后的原因（在<code>&lt;body&gt;</code>前面）。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>Vue常见面试题总结</title>
    <url>/2020/01/13/vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、什么是MVVM？"><a href="#一、什么是MVVM？" class="headerlink" title="一、什么是MVVM？"></a><strong>一、什么是MVVM？</strong></h1><p>MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p><a id="more"></a>
<p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h1 id="二、vue的优点是什么？"><a href="#二、vue的优点是什么？" class="headerlink" title="二、vue的优点是什么？"></a>二、vue的优点是什么？</h1><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>可重用性。可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p>
<p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h1 id="三、组件之间的传值？"><a href="#三、组件之间的传值？" class="headerlink" title="三、组件之间的传值？"></a>三、组件之间的传值？</h1><ul>
<li><p>父组件通过标签上<code>:data=data</code>方式定义传值</p>
</li>
<li><p>子组件通过<code>props</code>方法接受数据</p>
</li>
<li><p>子组件通过<code>$emit</code>方法传递参数</p>
<!-- more !-->
</li>
</ul>
<h1 id="四、vuex面试相关"><a href="#四、vuex面试相关" class="headerlink" title="四、vuex面试相关"></a>四、vuex面试相关</h1><p>（1）vuex是什么？怎么使用？哪种功能场景使用它？</p>
<p>vue框架中状态管理。在main.js引入store注入。新建一个目录store 。场景有：单页应用中，组件之间的状态，音乐播放、登录状态、加入购物车等。</p>
<h2 id="（2）vuex有哪几种属性？"><a href="#（2）vuex有哪几种属性？" class="headerlink" title="（2）vuex有哪几种属性？"></a>（2）vuex有哪几种属性？</h2><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module。</p>
<h2 id="（3）-vuex的State特性"><a href="#（3）-vuex的State特性" class="headerlink" title="（3） vuex的State特性"></a>（3） vuex的State特性</h2><p>Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。</p>
<p>state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。</p>
<p>通过mapState把全局 state 和 getters 映射到当前组件的 computed 计算属性中。</p>
<h2 id="（4）vuex的Getter特性"><a href="#（4）vuex的Getter特性" class="headerlink" title="（4）vuex的Getter特性"></a>（4）vuex的Getter特性</h2><p>getters 可以对State进行计算操作，它就是Store的计算属性。</p>
<p>虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。</p>
<p>如果一个状态只在一个组件内使用，可以不用getters。</p>
<h2 id="（5）vuex的Mutation特性"><a href="#（5）vuex的Mutation特性" class="headerlink" title="（5）vuex的Mutation特性"></a>（5）vuex的Mutation特性</h2><p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action 可以包含任意异步操作。</p>
<h2 id="（6）不用Vuex会带来什么问题？"><a href="#（6）不用Vuex会带来什么问题？" class="headerlink" title="（6）不用Vuex会带来什么问题？"></a>（6）不用Vuex会带来什么问题？</h2><p>可维护性会下降，想修改数据要维护三个地方；</p>
<p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p>
<p>增加耦合，大量的上传派发，会让耦合性大大增加，Vue用Component本意就是为了减少耦合，现在这么用，和组件化的初衷相背。</p>
<h1 id="五、v-show和v-if指令的共同点和不同点"><a href="#五、v-show和v-if指令的共同点和不同点" class="headerlink" title="五、v-show和v-if指令的共同点和不同点"></a>五、v-show和v-if指令的共同点和不同点</h1><p>v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏；</p>
<p>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果；</p>
<p>使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>
<h1 id="六、请列举出3个Vue中常用的生命周期钩子函数"><a href="#六、请列举出3个Vue中常用的生命周期钩子函数" class="headerlink" title="六、请列举出3个Vue中常用的生命周期钩子函数"></a>六、请列举出3个Vue中常用的生命周期钩子函数</h1><p>created: 实例创建完成之后调用，在这一步，实例已经完成数据观测、 属性和方法的运算、watch/event事件回调。然而，挂载阶段还没有开始, $el属性目前还不可见。</p>
<p><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p>activated: keep-alive组件激活时调用。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>全局过滤器</title>
    <url>/2018/07/26/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p> Vue.js 允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：插值表达式和 <code>v-bind</code> 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号（“|”）指示。使用方式为： msg | formatMsg，其中msg为要被过滤的文本，formatMsg为过滤器名称。 </p><a id="more"></a>
<p> 过滤器的定义方式： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.filter(&apos;formatMsg&apos;,function(msg)&#123;//对data数据进行处理的方法体&#125;);</span><br></pre></td></tr></table></figure>
<p> 这里定义了一个名为formatMsg的过滤器，过滤器的第一个参数为过滤器的名称；第二个参数为过滤方法，方法参数是要被过滤的文本，即管道符号前面的数据。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                msg:<span class="string">'曾经小小少年，有小小的梦，小小的开始，小小的进步，小小的实现'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这里只是在页面简单的展示了msg定义的数据。现在我们要使用过滤器把msg里文本为“小小”的字符串替换为“大大”。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">       &lt;p&gt;&#123;&#123; msg | formatMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p> 页面上调用名字为formatMsg的过滤器 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义过滤器</span><br><span class="line">Vue.filter(&apos;formatMsg&apos;,function(msg)&#123;</span><br><span class="line">       return msg.replace(/小小/g,&apos;大大&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 这里定义了名称为formatMsg的过滤器，过滤器中调用replace方法把“小小”替换为“大大” </p>
<p> 过滤器还可以添加任意多个参数 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg | formatMsg('超级','大大') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这里过滤器有两个参数，那么在定义过滤器时，应该在相对应的过滤方法中展示对应的参数： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.filter('formatMsg',function(msg,arg1,arg2)&#123;</span><br><span class="line">       return msg.replace(/小小/g,arg1 + arg2);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p> 这里过滤方法中的第一个参数为需要过滤的文本，后面的参数为过滤器调用时带的参数。</p>
<p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>前端面试题整理(HTML篇)</title>
    <url>/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h4 id="doctype-⽂档类型-的作用是什么？"><a href="#doctype-⽂档类型-的作用是什么？" class="headerlink" title="doctype(⽂档类型)的作用是什么？"></a><code>doctype</code>(⽂档类型)的作用是什么？</h4><p>位于文档第一行，告知浏览器文档使用哪种 HTML 规范。告诉浏览器按照何种规范解析页面 </p><h4 id="常用的浏览器以及内核都是什么"><a href="#常用的浏览器以及内核都是什么" class="headerlink" title="常用的浏览器以及内核都是什么"></a>常用的浏览器以及内核都是什么</h4><p>IE: trident</p><p>Firefox：gecko  </p><p>Safari:webkit </p><p>Opera: Blink </p><p>Chrome:Blink</p><h4 id="img标签的title和alt有什么区别？"><a href="#img标签的title和alt有什么区别？" class="headerlink" title="img标签的title和alt有什么区别？"></a><code>img</code>标签的<code>title</code>和<code>alt</code>有什么区别？</h4><a id="more"></a>





<p><code>title</code>属性是对图片的描述与进一步说明，会在鼠标移到元素上时显示一段提示文本 </p>
<p> <code>alt</code>属性是当图片无法显示的时候的替代文本</p>
<h4 id="描述一下渐进增强和优雅降级之间的不同"><a href="#描述一下渐进增强和优雅降级之间的不同" class="headerlink" title="描述一下渐进增强和优雅降级之间的不同 ?"></a>描述一下渐进增强和优雅降级之间的不同 ?</h4><p> 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 </p>
<p>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 。</p>
<h4 id="谈一下你对网页标准和标准制定机构重要性的理解"><a href="#谈一下你对网页标准和标准制定机构重要性的理解" class="headerlink" title="谈一下你对网页标准和标准制定机构重要性的理解"></a>谈一下你对网页标准和标准制定机构重要性的理解</h4><p>网页标准和标准制定机构都是为了能让<code>web</code>发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO 也会更好做不会因为滥用代码导致各种<code>BUG</code>、安全问题， 最终提高网站易用性 </p>
<h4 id="描述一下cookies，sessionStorage和-localStorage的区别"><a href="#描述一下cookies，sessionStorage和-localStorage的区别" class="headerlink" title="描述一下cookies，sessionStorage和 localStorage的区别"></a>描述一下<code>cookies</code>，<code>sessionStorage</code>和 <code>localStorage</code>的区别</h4><p><code>sessionStorage</code>中的数据， 数据在当前浏览器窗⼝关闭后⾃动删除</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</p>
<p><code>sessionStorage</code>和<code>localStorage</code>不会⾃动把数据发给服务器，仅在本地保存 </p>
<p><code>cookie</code>数据⼤⼩不能超过<code>4k</code> </p>
<p><code>sessionStorage</code>和<code>localStorage</code> 虽然也有存储⼤⼩的限制，但⽐<code>cookie</code>⼤得 多，可以达到<code>5M</code>或更⼤ </p>
<h4 id="src与href的区别？"><a href="#src与href的区别？" class="headerlink" title="src与href的区别？"></a><code>src</code>与<code>href</code>的区别？</h4><p><code>src</code>用于替代这个元素，而<code>href</code>用于建立这个标签与外部资源之间的关系。</p>
<p> <strong>src (Source)源</strong>这个属性是将资源嵌入到当前文档中元素所在的位置。 在请求<code>src</code>资源时会将其指向的资源下载并应用到当前文档中 </p>
<p> <strong>href</strong>这个属性指定<code>web</code>资源的位置，从而定义当前元素或当前文档与目标资源之间的联系。 </p>
<h4 id="一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验?"></a>一个页面上有大量的图片加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验?</h4><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p>
<p> 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先 下载。 </p>
<p>使用 CSSsprite，Iconfont技术。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图， 以提高用户体验。 </p>
<h4 id="语义化的理解"><a href="#语义化的理解" class="headerlink" title="语义化的理解"></a>语义化的理解</h4><p>就是让⻚⾯的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式 CSS 情况下也以⼀种⽂档格式显示，容易阅读。 搜索引擎的爬⾍依赖于标记来确定上下⽂和各个关键字的权重，利于 SEO 。 </p>
<h4 id="HTML块元素标签、行内元素标签都有哪些？"><a href="#HTML块元素标签、行内元素标签都有哪些？" class="headerlink" title="HTML块元素标签、行内元素标签都有哪些？"></a><code>HTML</code>块元素标签、行内元素标签都有哪些？</h4><p>块级元素 div  p  ul  li  table  h1 h2 h3 … h6  form 等  可以设置宽高  独占一行</p>
<p>行内元素 span  a  i  label  img  input  button  textarea select 等   不能设置宽高 不独占一行</p>
<p>行内块元素  综合了行内元素和块状元素的特性   就是不独占一行的块级元素 </p>
<h4 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h4><ul>
<li><p>用于绘画的 canvas 元素</p>
</li>
<li><p>用于媒介回放的 video 和 audio 元素</p>
</li>
<li>对本地离线存储的更好的支持</li>
<li>新的特殊内容元素，比如 article、footer、header、nav、section</li>
<li>新的表单控件，比如 calendar、date、time、email、url、search</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>关于position的六种属性</title>
    <url>/2018/05/29/%E5%85%B3%E4%BA%8Eposition%E7%9A%84%E5%85%AD%E7%A7%8D%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="position的定位属性"><a href="#position的定位属性" class="headerlink" title="position的定位属性"></a>position的定位属性</h2><h4 id="1、position：static（默认值）无特殊定位。"><a href="#1、position：static（默认值）无特殊定位。" class="headerlink" title="1、position：static（默认值）无特殊定位。"></a>1、position：static（默认值）无特殊定位。</h4><p>（1）元素出现在正常的流中（忽略top、bottom、left、right或者z-index的声明）<br>（2）当没有为元素指定方式时，默认为static，也就是按照文档的流式（flow）定位，将元素放到一个合适的地方。</p><h4 id="2、position：inherit-规定从父元素继承position的属性值。"><a href="#2、position：inherit-规定从父元素继承position的属性值。" class="headerlink" title="2、position：inherit 规定从父元素继承position的属性值。"></a>2、position：inherit 规定从父元素继承position的属性值。</h4><a id="more"></a>
<h4 id="3、position：relative-相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。"><a href="#3、position：relative-相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。" class="headerlink" title="3、position：relative 相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。"></a>3、position：relative 相对定位——相对于自己以前在标准流中的位置进行定位。元素通过偏移值（left、right、top、bottom）等属性在正常文档流中偏移位置。并且其不影响元素的本身特性，在没有定位偏移量时对元素无影响。</h4><p>（1）相对于定位元素来说仍然在文档流中，依然占据他本来的位置空间。<br>（2）由于其不脱离文档流，所以在相对定位中区分块级元素/行内元素/行内块元素。<br>（3）由于其不脱离文档流，并且相对定位元素会占用标准流中的位置，所以给相对定位元素设置magin/padding等属性会影响到标准流中的布局。<br>（4）提升层级，用z-index的样式可以改变一个元素的层级关系，从而改变覆盖关系，值大者在上面。<br>（注意：1.在没有脱离文档流的情况下，后渲染的元素会覆盖先渲染的元素。2.改变margin-left和在positon：relative的基础上改变left的效果类似）</p>
<h4 id="4、position：absolute-绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）"><a href="#4、position：absolute-绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）" class="headerlink" title="4、position：absolute 绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）"></a>4、position：absolute 绝对定位——相对于父元素（父元素设置了相对定位的元素）进行定位。（配合relative使用）</h4><p>（1）绝对定位元素脱离文档流，不占空间。<br>（2）绝对定位元素使行内元素在设置宽高时支持宽高，区块元素在设置宽度时由内容撑开宽度。<br>（3）相对于static以外的第一个祖先元素进行定位。（其父元素没有定位则逐层上找，直到document），元素位置通过偏移值（top、bottom、left、right）进行定位。<br>（4）用z-index可以提升层级关系，改变元素的覆盖关系。</p>
<h4 id="5、position：fixed-固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。"><a href="#5、position：fixed-固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。" class="headerlink" title="5、position：fixed 固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。"></a>5、position：fixed 固定定位——相对于浏览器窗口是固定位置。即使窗口有滚动条，也不会移动。</h4><p>（1）固定定位的元素是脱离文档流的，不占据标准流的空间。<br>（2）定位效果类似于固定背景，元素与视窗始终相对静止，元素位置通过偏移值来规定。<br>（3）Fixed定位的元素会和其他元素重叠。<br>（4）用z-index可以提升层级关系，改变元素的覆盖关系。</p>
<h4 id="6、position：sticky-粘性定位"><a href="#6、position：sticky-粘性定位" class="headerlink" title="6、position：sticky 粘性定位"></a>6、position：sticky 粘性定位</h4><p>元素按照普通文档流定位，然后相对于该元素在流中flow root（BFC）和containing block（最近的块级祖先元素）定位。而后，元素定位表现在跨越特定阈值前为相对定位，之后为固定定位。<br>（1）不脱离文档流，不会影响其他元素的正常显示。<br>（2）可以理解为是position：relative和position：fixed的结合体。即当元素在屏幕内时，表现为relative；就要滚出显示器屏幕的时候，表现为fixed。<br>（3）sticky元素的效果完全受制于父级元素们。<br>注意：<br>a.父级元素不能有任何overflow:visible以外的overflow设置，否则没有粘滞效果。<br>b.父级元素设置和粘性定位元素等高的固定的height高度值，或者高度计算值和粘性定位元素高度一样，也没有粘滞效果。<br>c.同一个父容器中的sticky元素，如果定位值相等，则会重叠;<br>d.sticky定位，不仅可以设置top，基于滚动容器上边缘定位；还可以设置bottom，相对底部粘滞。如果是水平滚动，也可以设置left和right值。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>前端面试题整理（CSS篇）</title>
    <url>/2021/06/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88CSS%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h4 id="介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同"><a href="#介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同" class="headerlink" title="介绍一下标准的css的盒子模型？低版本IE的盒子模型有什么不同"></a>介绍一下标准的<code>css</code>的盒子模型？低版本IE的盒子模型有什么不同</h4><p> 一个基本的盒模型，包括<code>content(width/height)</code>，<code>padding</code>，<code>border</code>，<code>margin</code> </p><p> 有两种盒子模型，<code>IE</code>盒模型和<code>W3C</code>标准盒模型，</p><p>两者的区别：W3C标准盒模型，宽高是只有内容content，没有padding和border的， 而IE盒模型，宽高不光有content，还包含了padding和border</p><a id="more"></a>


<h4 id="display-none与visibility-hidden的区别？"><a href="#display-none与visibility-hidden的区别？" class="headerlink" title="display:none与visibility:hidden的区别？"></a><code>display:none</code>与<code>visibility:hidden</code>的区别？</h4><p> display : 隐藏对应的元素但不挤占该元素原来的空间。 visibility: 隐藏对应的元素并且挤占该元素原来的空间。 </p>
<h4 id="为什么要初始化样式-？"><a href="#为什么要初始化样式-？" class="headerlink" title="为什么要初始化样式 ？"></a>为什么要初始化样式 ？</h4><p> 由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异但是初始化 <code>CSS</code>会对搜索引擎优化造成小影 </p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>坚持学习，坚持写博客，记录学习的点点滴滴！</title>
    <url>/2018/07/10/%E5%9D%9A%E6%8C%81%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%9D%9A%E6%8C%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%EF%BC%81/</url>
    <content><![CDATA[<p>还是太懒了，没有规划，没有目标，缺乏毅力！</p><p>长话短说，想成为一个优秀的程序员，还是需要不断的努力，不断的锤炼，不能懈怠！</p><p>从现在开始坚持学习，坚持写博客，记录学习的点点滴滴！</p>]]></content>
  </entry>
  <entry>
    <title>子盒子在父盒子中水平垂直居中的方法</title>
    <url>/2018/05/30/%E5%AD%90%E7%9B%92%E5%AD%90%E5%9C%A8%E7%88%B6%E7%9B%92%E5%AD%90%E4%B8%AD%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="子盒子在父盒子中水平垂直居中有几种方法？"><a href="#子盒子在父盒子中水平垂直居中有几种方法？" class="headerlink" title="子盒子在父盒子中水平垂直居中有几种方法？"></a>子盒子在父盒子中水平垂直居中有几种方法？</h1><h4 id="（定位、弹性盒子）"><a href="#（定位、弹性盒子）" class="headerlink" title="（定位、弹性盒子）"></a>（定位、弹性盒子）</h4><p>水平垂直居中：</p><h5 id="1-定位position-margin外边距（需要知道子盒子的宽高）"><a href="#1-定位position-margin外边距（需要知道子盒子的宽高）" class="headerlink" title="1.定位position+margin外边距（需要知道子盒子的宽高）"></a>1.定位position+margin外边距（需要知道子盒子的宽高）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父盒子*/</span><br><span class="line">position: relative;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*子盒子*/</span><br><span class="line">position: absolute;            </span><br><span class="line">top: 50%;            </span><br><span class="line">left: 50%;            </span><br><span class="line">margin-top: -50px;            </span><br><span class="line">margin-left: -50px;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h5 id="2-定位position-transform（不需要知道宽高）"><a href="#2-定位position-transform（不需要知道宽高）" class="headerlink" title="2.定位position+transform（不需要知道宽高）"></a>2.定位position+transform<strong>（不需要知道宽高）</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父盒子*/</span><br><span class="line">position: relative;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*子盒子*/</span><br><span class="line">position: absolute;            </span><br><span class="line">top: 50%;            </span><br><span class="line">left: 50%;            </span><br><span class="line">transform: translate(-50%,-50%);</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：1. 内容可变高度 2. 代码量少</p>
<p>缺点： 1. IE8不支持 2. 属性需要写浏览器厂商前缀 3. 可能干扰其他transform效果 4. 某些情形下会出现文本或元素边界渲染模糊的现象</p>
<h5 id="3-使用弹性盒子flex布局（不需要知道宽高）"><a href="#3-使用弹性盒子flex布局（不需要知道宽高）" class="headerlink" title="3.使用弹性盒子flex布局（不需要知道宽高）"></a>3.使用弹性盒子flex布局（不需要知道宽高）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*父盒子*/ </span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center; </span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>
<h5 id="4-margin：auto（不需要知道宽高）"><a href="#4-margin：auto（不需要知道宽高）" class="headerlink" title="4.margin：auto（不需要知道宽高）"></a>4.margin：auto（不需要知道宽高）</h5><p>父盒子本身需要宽度；</p>
<p>设置margin自动适应，然后设置定位的上下左右都为0，就如四边均衡受力从而实现盒子的居中；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: absolute;        </span><br><span class="line"> left:0;        </span><br><span class="line"> right:0;        </span><br><span class="line"> top: 0;        </span><br><span class="line"> bottom: 0;       </span><br><span class="line"> margin: auto;</span><br></pre></td></tr></table></figure>
<p> 如果父子元素都有设置宽高：<code>margin: 150px auto;</code> </p>
<h5 id="5-table-cell"><a href="#5-table-cell" class="headerlink" title="5.table-cell"></a>5.table-cell</h5><p>将父盒子设置为table-cell(能够使元素呈单元格的样式显示)，并设置text-align: center(使内容水平居中)；vertical-align: middle(使内容垂直居中);。子盒子设置为inline-block可以使其内容变为文本格式，也可设置宽高；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father&#123;    </span><br><span class="line">	display: table-cell;    </span><br><span class="line">	width: 400px;    </span><br><span class="line">	height: 400px;    </span><br><span class="line">	vertical-align: middle;     </span><br><span class="line">	text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.child&#123;    </span><br><span class="line">	display: inline-block;    </span><br><span class="line">	vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>插值表达式和v-text的区别</title>
    <url>/2018/07/16/%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cv-text%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。"><a href="#页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。" class="headerlink" title="页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。"></a>页面频繁刷新或者网速很慢的时候，页面会先出现源代码，再一闪而过出现真实的数据。</h4><p>对于这个问题Vue给予了解决办法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p v-cloak&gt; &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p> 节点中我们定义了 Vue 的内置属性 “v-cloak” </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">      <span class="selector-attr">[v-cloak]</span>&#123;</span><br><span class="line">          <span class="attribute">display</span>:none;</span><br><span class="line">      &#125;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了样式：包含属性“v-cloak”的节点默认隐藏</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el : <span class="string">"#app"</span>,</span><br><span class="line">            data : &#123;</span><br><span class="line">                msg : <span class="string">"Hello Vue"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建Vue对象，并与id为“app”的节点绑定。</p>
<p>这时如果再在页面访问发现：如果页面加载很慢的时候，不会再出现源代码，直接是一片空白，当Vue数据传递完成时，会正确显示数据。</p>
<p> Vue在页面数据传递时，如果一开始插值表达式获取不到数据，那么包含“v-cloak”属性的节点就会执行“display:none”样式，导致页面什么也看不到，当插值表达式获取到数据之后，就会在节点中自动移除“v-cloak”属性，这时样式也就不起作用了，展示了正常的数据。这时估计有人就会抱怨尤大神了，能一下都解决了吗？ </p>
<h4 id="指令：v-text"><a href="#指令：v-text" class="headerlink" title="指令：v-text"></a>指令：v-text</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p v-cloak&gt; &#123;&#123; msg &#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p v-text="msg"&gt;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果完全一样，页面元素也一样。但是这时候你把网速调的很慢会发现，“v-text”这个属性在页面数据加载没完成的时候不会出现源代码。那为什么有这个了为什么还要用插值表达式？ </p>
<p>因为 v-text替换元素中所有的文本，插值表达式只替换自己，不清空元素内容 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span>----&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   //waynelee</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>----&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>          //----waynelee</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>1、如果要同时展示用户前台数据，那么就需要用插值表达式，但是不要添加“v-cloak”属性。</p>
<p>2、如果只是单独展示Vue对象里的数据，建议使用“v-text”指令。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>清除浮动的方式</title>
    <url>/2018/06/02/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="为什么要清除浮动？怎么清除浮动？"><a href="#为什么要清除浮动？怎么清除浮动？" class="headerlink" title="为什么要清除浮动？怎么清除浮动？"></a>为什么要清除浮动？怎么清除浮动？</h1><p><strong>产生原因</strong>：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生<strong>高度塌陷</strong>的情况。</p><p><strong>带来的负作用</strong>：</p><ol>
<li><strong>背景</strong>不能显示</li>
<li><strong>边框</strong>不能撑开</li>
<li><strong>margin和padding值</strong>不能正确显示</li>
</ol><p><strong>清除浮动的方法</strong>：</p><ol>
<li><p>给<strong>父盒子</strong>设置合适的<strong>高度、border、padding</strong>；</p>
</li>
<li><p>【推荐】给<strong>父盒子添加样式 <code>overflow:hidden/auto;</code></strong></p>
<p>（这个属性相当于触发BFC，让父级紧贴内容，包括使用了浮动的盒子）</p>
<p>（为了去除兼容性问题，会添加<code>zoom:1;</code>）</p>
</li>
<li><p>在父盒子里面的子盒子后面<strong>添加一个子盒子</strong>，如div，<strong>添加样式 <code>.clear{ clear:both; }</code>；</strong></p>
</li>
<li><p>采用<strong>伪元素，给父元素追加<code>:after</code></strong>，给父元素添加一个类<code>.clearfix{content:&quot;&quot;;clear:both;}</code></p>
</li>
</ol><a id="more"></a>




<p><strong>BFC块级格式化上下文的特征</strong>：</p>
<ul>
<li><p>内部的Box会在<strong>垂直方向</strong>，从顶部开始<strong>一个接一个</strong>地放置；</p>
</li>
<li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个<strong>相邻Box的margin会发生叠加</strong>。</p>
</li>
<li><p>每个元素的margin box的左边， <strong>与包含块</strong>border box的<strong>左边相接触</strong>，即使存在浮动也是如此。</p>
</li>
<li><p>BFC的区域不会与float box叠加。</p>
</li>
<li><p>BFC就是页面上的一个<strong>隔离的独立容器</strong>，容器里面的子元素<strong>不会影响到外面的元素</strong>，反之亦然。</p>
</li>
<li><p>计算BFC的高度时，<strong>浮动元素也参与计算</strong>。</p>
</li>
</ul>
<p>注意：块格式化上下文<strong>包含创建它的元素内部的所有内容</strong>；<strong>创建块级格式化上下文</strong>：</p>
<ul>
<li><strong>浮动</strong> (元素的 float不为 none）</li>
<li><strong>绝对定位元素</strong> (元素的 position为 absolute 或 fixed)</li>
<li><strong>行内块</strong> inline-blocks (元素的 display: inline-block)</li>
<li><strong>表格单元格</strong> (元素的 display: table-cell，HTML表格单元格默认属性)</li>
<li><strong>表格标题</strong> (元素的 display: table-caption，HTML表格标题默认属性)</li>
<li><strong>overflow的值不为 visible的元素</strong>(元素的 overflow: hidden，overflow: auto)</li>
<li><strong>弹性盒</strong>子 flex boxes (元素的 display: flex 或 inline-flex)</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>文字简单跑马灯效果</title>
    <url>/2018/07/17/%E6%96%87%E5%AD%97%E7%AE%80%E5%8D%95%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跑马灯效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>　　<span class="comment">&lt;!-- 页面部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"go()"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"stop()"</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">　　<span class="comment">&lt;!-- JS部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el : <span class="string">"#app"</span>,</span></span><br><span class="line">            data : &#123;</span><br><span class="line"><span class="javascript">                msg : <span class="string">'好好努力，加油加油每一天'</span>,<span class="comment">//跑马灯文字</span></span></span><br><span class="line"><span class="javascript">                interObj : <span class="literal">null</span>  <span class="comment">//定时器对象</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods : &#123;</span><br><span class="line">               </span><br><span class="line">                go()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(<span class="keyword">this</span>.interObj == <span class="literal">null</span>)&#123;</span></span><br><span class="line"><span class="javascript">                        _this = <span class="keyword">this</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.interObj = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                        　　<span class="keyword">let</span> start = _this.msg.substring(<span class="number">0</span>,<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                        　　<span class="keyword">let</span> end = _this.msg.substring(<span class="number">1</span>);</span></span><br><span class="line">                        　　_this.msg = end + start;</span><br><span class="line">                    　　&#125;,1000);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;,</span><br><span class="line">                stop()&#123;</span><br><span class="line"><span class="javascript">                    clearInterval(<span class="keyword">this</span>.interObj);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.interObj = <span class="literal">null</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>
<p>代码分析：</p>
<p>页面上定义两个按钮，分别用来触发跑马灯效果和停止跑马灯效果。js部分分别定义了两个对象以及对应的方法。</p>
<p>1、go方法主要是使用定时器，每次把msg文本分成两个部分start和end，start为msg下标为0的字符串，end为msg下标为1至结尾的字符串，然后把end和start拼接为一个新的字符串赋值给msg，从而实现类似于跑马灯的效果。</p>
<p>2、stop方法用来清除定时器，终止跑马灯效果。</p>
<p>3、methods方法里想要使用data里的数据，需要使用关键字：this，但是这里要注意this作用域的范围。</p>
<p>4、可以看到每次改变msg文本内容的时候都会立刻反应在页面上，从侧面可以看出Vue响应式的特点。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>盒模型有那些</title>
    <url>/2018/05/31/%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%9C%89%E9%82%A3%E4%BA%9B/</url>
    <content><![CDATA[<h1 id="盒模型有哪些？有什么区别？"><a href="#盒模型有哪些？有什么区别？" class="headerlink" title="盒模型有哪些？有什么区别？"></a>盒模型有哪些？有什么区别？</h1><p>盒模型分为IE盒模型和W3C标准盒模型。</p><ol>
<li><strong>W3C 标准盒模型content-box</strong>：属性width,height只包含内容content，不包含border和padding。</li>
<li><strong>IE 盒模型border-box</strong>：属性width,height包含border和padding，指的是content+padding+border。</li>
</ol><a id="more"></a>

<p><strong>box-sizing</strong>控制，默认值为<strong>content-box，即标准盒模型</strong>；<strong>border-box则用的是IE盒模型</strong></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>简单计算器实现</title>
    <url>/2018/07/19/%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p> 需要掌握JavaScript的eval()函数，其主要是用来计算某个字符串，并执行其中的 JavaScript 代码。 </p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>计算器功能简单模拟<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"n1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"opt"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>+<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>*<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>/<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"n2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"equal"</span>&gt;</span>=<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"result"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- js代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                n1:0,</span><br><span class="line">                n2:0,</span><br><span class="line"><span class="javascript">                opt:<span class="string">'-'</span>,</span></span><br><span class="line">                result:0</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                equal()&#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> optStr = <span class="string">'parseInt(this.n1)'</span> + <span class="keyword">this</span>.opt + <span class="string">'parseInt(this.n2)'</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.result = <span class="built_in">eval</span>(optStr);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p> 功能很简单，核心是利用双向数据绑定的原理，实现数据实时计算。n1和n2是参与计算的变量，result是计算结果，一开始都被初始化为0，操作符被初始化为减号，通过点击等于号button触发计算方法，计算的结果会被实时显示出来。计算方法中为了实现简单使用了eval()函数，其会把字符串解析出来，按照正常的计算逻辑计算结果。 </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
